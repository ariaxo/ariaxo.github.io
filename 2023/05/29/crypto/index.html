<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>数论与密码学手册 | Voidhead</title>
  <meta name="author" content="Ariax">
  
  <meta name="description" content="mod（%）运算（建议应当相当熟悉这个链接以及相关链接的内容）
笔者正在恶补数学……
目录


质数/素数



欧几里得算法（Euclidean algorithm）



费马小定理



拓展欧几里得算法


4.1. 求逆元



贝祖等式



中国剩余定理



一次一密（One-Time Pad）：



*分组密码



线性反馈移位寄存器



RC4算法


10.1. 编程”实现”SHA-1: 见write-ups吧



RSA与DSA算法


11.1. 编程“实现”RSA



Diffie-Hellman &amp;amp; Elgamal



数字签名/证书



椭圆曲线算法









数学基础1. 质数/素数只有1与本身两个因数的正整数。
6.3注：大整数分解困难问题是RSA算法的基础。另还有基于离散对数困难问题的Diffie-Hellman密钥交换协议、Elgamal加密以及DSA算法、基于椭圆曲线上离散对数困难问题的椭圆曲线密码体制。
整除的概念（拓展到多项式即为环）
素数的分布（黎曼猜想）、无限性证明（反证法）">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="数论与密码学手册"/>
  <meta property="og:site_name" content="Voidhead"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Voidhead" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

 <body>  
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Voidhead</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/links" title="Friends">
			  <i class=""></i>Friends
			</a>
		  </li>
		  
		  <li>
			<a href="/misc" title="Miscs">
			  <i class=""></i>Misc
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> 数论与密码学手册</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p><a href=https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%AE%97%E6%95%B8>mod（%）运算（建议应当相当熟悉这个链接以及相关链接的内容）</a></p>
<p>笔者正在恶补数学……</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><!-- vscode-markdown-toc -->
<ul>
<li><ol>
<li><a href="#">质数/素数</a></li>
</ol>
</li>
<li><ol start="2">
<li><a href="#Euclideanalgorithm">欧几里得算法（Euclidean algorithm）</a></li>
</ol>
</li>
<li><ol start="3">
<li><a href="#-1">费马小定理</a></li>
</ol>
</li>
<li><ol start="4">
<li><a href="#-1">拓展欧几里得算法</a></li>
</ol>
<ul>
<li>4.1. <a href="#-1">求逆元</a></li>
</ul>
</li>
<li><ol start="5">
<li><a href="#-1">贝祖等式</a></li>
</ol>
</li>
<li><ol start="6">
<li><a href="#-1">中国剩余定理</a></li>
</ol>
</li>
<li><ol start="7">
<li><a href="#One-TimePad">一次一密（One-Time Pad）：</a></li>
</ol>
</li>
<li><ol start="8">
<li><a href="#-1">*分组密码</a></li>
</ol>
</li>
<li><ol start="9">
<li><a href="#-1">线性反馈移位寄存器</a></li>
</ol>
</li>
<li><ol start="10">
<li><a href="#RC4">RC4算法</a></li>
</ol>
<ul>
<li>10.1. <a href="#SHA-1:write-ups">编程”实现”SHA-1: 见write-ups吧</a></li>
</ul>
</li>
<li><ol start="11">
<li><a href="#RSADSA">RSA与DSA算法</a></li>
</ol>
<ul>
<li>11.1. <a href="#RSA">编程“实现”RSA</a></li>
</ul>
</li>
<li><ol start="12">
<li><a href="#Diffie-HellmanElgamal">Diffie-Hellman &amp; Elgamal</a></li>
</ol>
</li>
<li><ol start="13">
<li><a href="#-1">数字签名/证书</a></li>
</ol>
</li>
<li><ol start="14">
<li><a href="#-1">椭圆曲线算法</a></li>
</ol>
</li>
</ul>
<!-- vscode-markdown-toc-config
    numbering=true
    autoSave=true
    /vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->




<h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="1-质数-素数"><a href="#1-质数-素数" class="headerlink" title="1. 质数/素数"></a>1. <a name=''></a>质数/素数</h2><p>只有1与本身两个因数的正整数。</p>
<p>6.3注：大整数分解困难问题是RSA算法的基础。另还有基于离散对数困难问题的Diffie-Hellman密钥交换协议、Elgamal加密以及DSA算法、基于椭圆曲线上离散对数困难问题的椭圆曲线密码体制。</p>
<p>整除的概念（拓展到多项式即为环）</p>
<p>素数的分布（黎曼猜想）、无限性证明（反证法）</p>
<h2 id="Eratoshenes-sieve"><a href="#Eratoshenes-sieve" class="headerlink" title="Eratoshenes sieve"></a>Eratoshenes sieve</h2><p>例：找出小于或等于30的所有素数。</p>
<p>步骤1：创建一个包含从2到30的所有整数的列表。</p>
<pre><code>2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
</code></pre>
<p>步骤2：从列表中选择第一个数，也就是2，将2的倍数从列表中移除。</p>
<pre><code>2 3 5 7 9 11 13 15 17 19 21 23 25 27 29
</code></pre>
<p>步骤3：选择下一个未被标记的数，也就是3，将3的倍数从列表中移除。</p>
<pre><code>2 3 5 7 11 13 17 19 23 25 29
</code></pre>
<p>步骤4：继续这个过程，选择下一个未被标记的数，直到达到了30的平方根（即5），因为在那之后的数都已经被标记或移除了。</p>
<p>步骤5：剩下的未被标记的数就是小于或等于30的所有素数。</p>
<p>E seive是确定性方法，而Miller Rabin素性检验是概率性方法。</p>
<h2 id="2-欧几里得算法（Euclidean-algorithm）"><a href="#2-欧几里得算法（Euclidean-algorithm）" class="headerlink" title="2. 欧几里得算法（Euclidean algorithm）"></a>2. <a name='Euclideanalgorithm'></a>欧几里得算法（Euclidean algorithm）</h2><p>我的理解中欧几里得算法即为，任意整数都可以被任意正整数线性表示，即a = q*b+r</p>
<p>欧几里得算法最大的应用是计算两个整数最大公约数（GCD）</p>
<blockquote>
<p>例如，我们要计算 72 和 30 的最大公约数：<br>a = 72，b = 30。<br>72 除以 30 得到商 2 和余数 12。<br>12 不等于 0，所以将 30 的值赋给 a，将 12 的值赋给 b。<br>a = 30，b = 12。<br>30 除以 12 得到商 2 和余数 6。<br>6 不等于 0，所以将 12 的值赋给 a，将 6 的值赋给 b。<br>a = 12，b = 6。<br>12 除以 6 得到商 2 和余数 0。<br>余数为 0，所以最大公约数为 6。</p>
</blockquote>
<p>而拓展欧几里得算法中GCD（a，b）也可以被a，b线性表示，即GCD（a，b）= s<em>a + t</em>b</p>
<h2 id="欧拉函数与欧拉定理"><a href="#欧拉函数与欧拉定理" class="headerlink" title="欧拉函数与欧拉定理"></a>欧拉函数与欧拉定理</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0</a></p>
<p>整数m＞1，（a，m）＝1，则a^E(m)与1同模m</p>
<h2 id="3-费马小定理"><a href="#3-费马小定理" class="headerlink" title="3. 费马小定理"></a>3. <a name='-1'></a>费马小定理</h2><p>如果 p 是一个质数，a 是任意不可被 p 整除的整数，则有：</p>
<pre><code>a^(p-1) ≡ 1 (mod p)
</code></pre>
<p>其中，^ 表示乘方运算，≡ 表示模运算的等价关系，即两边模 p 后的结果相等。</p>
<p>费马小定理的一个直接推论是，如果 p 是一个质数，a 是任意整数，则有：</p>
<pre><code>a^p ≡ a (mod p)
</code></pre>
<p>但是反之，满足费马小定理的数不一定是素数。参见<a href=https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E4%BC%AA%E7%B4%A0%E6%95%B0>费马伪素数</a>。</p>
<h2 id="4-拓展欧几里得算法"><a href="#4-拓展欧几里得算法" class="headerlink" title="4. 拓展欧几里得算法"></a>4. <a name='-1'></a>拓展欧几里得算法</h2><p>拓展欧几里得算法的基本思想是从最后一步欧几里得算法开始逆向推导，通过反复应用欧几里得算法的辗转相除过程，同时更新贝祖等式的系数。具体步骤如下：</p>
<blockquote>
<p>初始化：令 a0 = a，b0 = b，x0 = 1，y0 = 0，x1 = 0，y1 = 1。<br>迭代计算：通过连续应用欧几里得算法的辗转相除过程，更新 a、b 和 x、y 的值，直到余数为 0。计算商和余数：q = a[i-1] // b[i-1]，r = a[i-1] % b[i-1]。<br>更新 a、b：a[i] = b[i-1]，b[i] = r。<br>更新 x、y：x[i] = x[i-2] - q * x[i-1]，y[i] = y[i-2] - q * y[i-1]。<br>输出结果：最大公约数为 b[n-1]，x[n-1] 和 y[n-1] 分别是贝祖等式 ax + by = gcd(a, b) 中的系数。</p>
</blockquote>
<p>拓展欧几里得算法在密码学中常用于求解<strong>模逆元</strong>的问题，即找到一个数的乘法逆元（模某个数的余数下的倒数）。</p>
<h3 id="4-1-求逆元"><a href="#4-1-求逆元" class="headerlink" title="4.1. 求逆元"></a>4.1. <a name='-1'></a>求逆元</h3><h2 id="5-贝祖等式"><a href="#5-贝祖等式" class="headerlink" title="5. 贝祖等式"></a>5. <a name='-1'></a>贝祖等式</h2><p>对于任意两个整数 a 和 b，存在整数 x 和 y，使得它们满足以下等式：</p>
<pre><code>ax + by = gcd(a, b)
</code></pre>
<p>其中，gcd(a, b) 表示 a 和 b 的最大公约数。</p>
<p>相关阅读：<a href=https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B>线性同余方程</a></p>
<h2 id="6-中国剩余定理"><a href="#6-中国剩余定理" class="headerlink" title="6. 中国剩余定理"></a>6. <a name='-1'></a>中国剩余定理</h2><p>中国剩余定理的一般形式如下：</p>
<p>给定一组正整数 m₁, m₂, …, mₙ 两两互质，以及任意的整数 a₁, a₂, …, aₙ，中国剩余定理说明存在一个整数 x，满足以下条件：</p>
<p>x ≡ a₁ (mod m₁)</p>
<p>x ≡ a₂ (mod m₂)</p>
<p>…</p>
<p>x ≡ aₙ (mod mₙ)</p>
<p>中国剩余定理可以找到一个满足多个模同余条件的整数。</p>
<p>以下为一个例子</p>
<img src=/img/crt.jpg>

<h1 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h1><p>对称密钥加密是一种加密技术，其中使用相同的密钥（称为对称密钥）用于加密和解密数据。发送方使用密钥将明文（原始数据）转换为密文（加密后的数据），而接收方使用相同的密钥将密文转换回明文。</p>
<p>在对称密钥加密中，加密和解密过程使用相同的密钥，因此需要确保密钥的保密性。如果第三方获得了密钥，他们就可以轻松地解密和访问加密的数据。</p>
<h2 id="7-一次一密（One-Time-Pad）："><a href="#7-一次一密（One-Time-Pad）：" class="headerlink" title="7. 一次一密（One-Time Pad）："></a>7. <a name='One-TimePad'></a>一次一密（One-Time Pad）：</h2><p>一次一密是一种理论上具有绝对安全性的加密方法。它使用与明文长度相等的随机密钥进行异或运算，生成密文。密钥只使用一次，然后丢弃，因此称为一次一密。解密时，使用相同的密钥对密文进行异或运算，可以得到原始的明文。</p>
<p>OTP可以保证<strong>Perfect Secrecy</strong>。<br>联想：HTTPS 协议中的完美前向保密性（Perfect Forward Secrecy）是指在通信过程中，即使长期主密钥（long-term master key）被攻击者获得，之前的通信记录也无法被解密。在 HTTPS 中，完美前向保密性通过使用临时的会话密钥（session key），每次会话都生成一个新的临时密钥，用于加密通信。即使攻击者获取了主密钥，他们也无法通过该主密钥解密之前的通信记录，因为会话密钥已经发生了变化。</p>
<p>与PFS方法不同，OTP方法在实践中并不常用。</p>
<h2 id="8-分组密码"><a href="#8-分组密码" class="headerlink" title="8. *分组密码"></a>8. <a name='-1'></a>*分组密码</h2><p>扩散与混淆<br>运行模式：*0+<br>OFB、CFB、CBC与ECB</p>
<h3 id="Feistel密码结构"><a href="#Feistel密码结构" class="headerlink" title="Feistel密码结构"></a>Feistel密码结构</h3><h3 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h3><p>明文密文分组长度64位，密钥64位（有效56位）</p>
<blockquote>
<p>在 DES 的 ECB 模式中，如果在密文［1］分组中有一个错误，解密后仅相应的明文［2］分组受到影响然而在 CBC 模式中，将有错误传播。C1中的一个错误明显地将影响到 P1和P2的结果<br>(1)P2后的分组是否受到影响？<br>（2）设加密前的明文分组P1中有1比特的错误，问这一错误将在多少个密文分组中传播？<br>对接收者产生什么影响？</p>
</blockquote>
<img src="/img/des1.jpg">

<p>** DES的解密变换是加密变换的逆</p>
<img src="/img/des2.jpg">

<img src="/img/des3.jpg">

<p><strong>DES算法中的轮结构与轮函数</strong>：16轮迭代轮函数共有8个s盒，其中每个i为6bit👉o为4bit。</p>
<p>*S盒如何将六位数据转换成4位：<br>例如，原始数据{1 0011 1 } ，取头尾数据11，十进制👉3即为行数</p>
<p>取中间数据0011，十进制👉3即为列数</p>
<p>在对应DES的S盒中查找就可以{十进制2👉0010                                                                                                                                                                                    }</p>
<p>二/三重DES</p>
<h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><p>{此处需要群/域的基础}，见<br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BE%A4">https://zh.wikipedia.org/wiki/%E7%BE%A4</a> 中的“定义”，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%9F_(%E6%95%B0%E5%AD%A6)">https://zh.wikipedia.org/wiki/%E5%9F%9F_(%E6%95%B0%E5%AD%A6)</a></p>
<img src="/img/aes1.jpg">
<img src="/img/aes2.jpg">
<img src="/img/aes3.jpg">
<img src="/img/aes4.jpg">

<p>*AES算法的分组大小128位，三种密码标准：128、256、192（位）</p>
<p>**AES算法的过程：AddRoundKey👉SubstituteBytes👉ShiftRows👉MixColumns<br><img src="/img/aes5.jpg"></p>
<h3 id="SM4算法"><a href="#SM4算法" class="headerlink" title="SM4算法"></a>SM4算法</h3><p>分组长度128bit=密钥长度</p>
<h1 id="流加密"><a href="#流加密" class="headerlink" title="流加密"></a>流加密</h1><h2 id="9-线性反馈移位寄存器"><a href="#9-线性反馈移位寄存器" class="headerlink" title="9. 线性反馈移位寄存器"></a>9. <a name='-1'></a>线性反馈移位寄存器</h2><p>线性反馈移位寄存器（Linear Feedback Shift Register，简称LFSR）是一种在计算机科学和密码学中常用的序列发生器。它是由多个寄存器和一组反馈函数组成的，通过对寄存器中的位进行移位和异或操作来生成一个伪随机的二进制序列。</p>
<p>以下为一个例子：</p>
<h2 id="10-RC4算法"><a href="#10-RC4算法" class="headerlink" title="10. RC4算法"></a>10. <a name='RC4'></a>RC4算法</h2><h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>引入哈希函数主要是为了保证数据完整性（这与隐私是不同的）</p>
<p>哈希函数是一种将输入数据（消息）转换为固定长度输出（哈希值）的函数。</p>
<ol>
<li><p>抗原象性（Preimage Resistance）：对于给定的哈希值，很难找到一个与之对应的输入消息。也就是说，对于任意给定的哈希值，计算出其对应的输入消息应该是困难的。这意味着哈希函数应该是单向的，不可逆的。</p>
</li>
<li><p>抗第二原像性（Second Preimage Resistance）：给定一个输入消息，很难找到另一个不同的输入消息，使得它们具有相同的哈希值。也就是说，对于已知的输入消息，计算出与之具有相同哈希值的其他输入消息应该是困难的。</p>
</li>
<li><p>抗碰撞性（Collision Resistance）：很难找到两个不同的输入消息，使得它们具有相同的哈希值。也就是说，计算出两个具有相同哈希值的不同输入消息应该是困难的。</p>
</li>
<li><p>生日攻击（Birthday Attack）：生日攻击是一种特殊的攻击方式，利用生日悖论的原理，在较短的时间内找到两个具有相同哈希值的输入消息的概率较高。哈希函数应该抵抗生日攻击，即使在较长的时间内，找到具有相同哈希值的输入消息的概率也应该非常低。</p>
</li>
</ol>
<blockquote>
<p>生日攻击利用了概率学中的生日悖论，即在一组人中，只需要有23个人，就存在两个人生日相同的概率超过一半。类似地，在哈希函数中，由于输出空间的大小有限，当输入消息的数量足够大时，存在相同哈希值的输入消息的概率变得非常高。</p>
</blockquote>
<blockquote>
<p>为了抵抗生日攻击，通常的做法是使用更长的哈希值，例如SHA-256（256位哈希值）或SHA-3（Keccak）系列。这增加了哈希值的空间大小，降低了相同哈希值的概率。此外，还有一些专门设计的哈希函数，如HMAC（Hash-based Message Authentication Code）和SHA-3家族中的SHAKE函数，用于抵御生日攻击。</p>
</blockquote>
<p>总结来说，即为产生MAC、传输MAC、验证MAC</p>
<h3 id="10-1-编程”实现”SHA-1-见write-ups吧"><a href="#10-1-编程”实现”SHA-1-见write-ups吧" class="headerlink" title="10.1. 编程”实现”SHA-1: 见write-ups吧"></a>10.1. <a name='SHA-1:write-ups'></a>编程”实现”SHA-1: 见write-ups吧</h3><p>如何利用哈希函数构造MAC？</p>
<h1 id="公钥密码"><a href="#公钥密码" class="headerlink" title="*公钥密码"></a>*公钥密码</h1><p>这部分需要详细学习（尤其是RSA非常重要）</p>
<p>对称密码体制缺乏开放的系统，依赖信道的可靠性、密钥管理困难，用户量增加时密钥空间急剧增大、难以实现抗抵赖。</p>
<p>公钥密码使用两个密钥：公开密钥与秘密密钥，加密解密非对称。模型：KeyGen()-&gt;(pk,sk);Enc(pk,m)-&gt;c;Dec(sk,c)-&gt;m</p>
<h2 id="11-RSA与DSA算法"><a href="#11-RSA与DSA算法" class="headerlink" title="11. RSA与DSA算法"></a>11. <a name='RSADSA'></a>RSA与DSA算法</h2><p>RSA证明方法：</p>
<p>安全性基于大整数分解：RSA的安全性基于大整数分解的困难性。证明方法是通过选择两个大素数 p 和 q，并计算它们的乘积 n = p * q。然后选择一个与 (p-1)(q-1) 互质的整数 e 作为公钥指数，以及计算出满足 (d * e) mod ((p-1)(q-1)) = 1 的私钥指数 d。公钥是 (n, e)，私钥是 (n, d)。</p>
<p>RSA的安全性取决于大整数分解的困难性，即从 n 中分解出 p 和 q 的困难性。大整数分解是一个耗时的计算问题，尚未发现有效的算法可以在可接受的时间内分解大素数的乘积。</p>
<img src="/img/rsa1.jpg">

<h3 id="11-1-编程“实现”RSA"><a href="#11-1-编程“实现”RSA" class="headerlink" title="11.1. 编程“实现”RSA"></a>11.1. <a name='RSA'></a>编程“实现”RSA</h3><pre><code>// 生成RSA密钥对
function generateRSAKeyPair() &#123;
  var keySize = 2048; // 密钥大小
  var e = new BigInteger(&quot;65537&quot;); // 公钥指数
  var p = BigInteger.probablePrime(keySize / 2, rng); // 随机生成素数 p
  var q = BigInteger.probablePrime(keySize / 2, rng); // 随机生成素数 q
  var n = p.multiply(q); // 计算 n = p * q
  var phi = p.subtract(1).multiply(q.subtract(1)); // 计算 φ(n) = (p - 1) * (q - 1)
  var d = e.modInverse(phi); // 计算私钥指数 d = e^(-1) mod φ(n)
  var publicKey = &#123; e: e, n: n &#125;; // 公钥 (e, n)
  var privateKey = &#123; d: d, n: n &#125;; // 私钥 (d, n)
  return &#123; publicKey: publicKey, privateKey: privateKey &#125;;
&#125;

// RSA加密
function rsaEncrypt(plaintext, publicKey) &#123;
  var message = new BigInteger(plaintext); // 将明文转换为大整数
  var e = publicKey.e;
  var n = publicKey.n;
  var ciphertext = message.modPow(e, n); // 加密操作：c = m^e mod n
  return ciphertext.toString();
&#125;

// RSA解密
function rsaDecrypt(ciphertext, privateKey) &#123;
  var c = new BigInteger(ciphertext); // 将密文转换为大整数
  var d = privateKey.d;
  var n = privateKey.n;
  var plaintext = c.modPow(d, n); // 解密操作：m = c^d mod n
  return plaintext.toString();
&#125;

// 示例用法
var plaintext = &quot;Hello, RSA!&quot;;
var keyPair = generateRSAKeyPair();
var publicKey = keyPair.publicKey;
var privateKey = keyPair.privateKey;

var ciphertext = rsaEncrypt(plaintext, publicKey);
console.log(&quot;Ciphertext:&quot;, ciphertext);

var decryptedText = rsaDecrypt(ciphertext, privateKey);
console.log(&quot;Decrypted Text:&quot;, decryptedText);
</code></pre>
<h2 id="DSA证明方法："><a href="#DSA证明方法：" class="headerlink" title="DSA证明方法："></a>DSA证明方法：</h2><p>安全性基于离散对数问题：DSA的安全性基于离散对数问题的困难性。证明方法是通过选择一个大素数 p，并选择一个模 p 的生成元 g。然后生成一个私钥 x，满足 0 &lt; x &lt; p-1。计算公钥 y = g^x mod p。公钥是 (p, g, y)，私钥是 x。</p>
<p>DSA的安全性取决于离散对数问题的困难性，即计算 g^x mod p 中的 x 的困难性。离散对数问题是一个复杂的计算问题，在<strong>合理的</strong>时间内计算出离散对数是困难的。</p>
<h2 id="12-Diffie-Hellman-amp-Elgamal"><a href="#12-Diffie-Hellman-amp-Elgamal" class="headerlink" title="12. Diffie-Hellman &amp; Elgamal"></a>12. <a name='Diffie-HellmanElgamal'></a>Diffie-Hellman &amp; Elgamal</h2><p>Diffie-Hellman &amp; Elgamal 也都基于数论中的<strong>离散对数问题</strong></p>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/523658036">https://zhuanlan.zhihu.com/p/523658036</a></p>
<h2 id="13-数字签名-证书"><a href="#13-数字签名-证书" class="headerlink" title="13. 数字签名/证书"></a>13. <a name='-1'></a>数字签名/证书</h2><p>消息认证（上文哈希）保护通信免受第三方攻击，但不能防止通信中另一方的欺骗和伪造</p>
<p>几个点：RSA/DSA数字签名算法、Elgamal数字签名体制、Schnorr签名体制</p>
<h2 id="14-椭圆曲线算法ECC"><a href="#14-椭圆曲线算法ECC" class="headerlink" title="14. 椭圆曲线算法ECC"></a>14. <a name='-1'></a>椭圆曲线算法ECC</h2><p>RSA、Elgamal为了保障安全性，常常采用长度很大的密钥，而椭圆密码体系可以用更小的尺寸得到同样的安全性。</p>
<p>总结公钥密码：公钥密码解决了对称密码“密钥管理麻烦、开放性差”的缺点，但这不意味著公钥密码的出现使对称密码“过时”了，也不意味着公钥密码体系更安全。同时，公钥密码加密解密速度较慢。</p>
<h1 id="密钥管理与分配"><a href="#密钥管理与分配" class="headerlink" title="密钥管理与分配"></a>密钥管理与分配</h1><p>最后说下这个，单钥加密体制（也就是对称加密体制）密钥分配的基本方法根据有无密钥分配中心KDC分为两种，密钥会话是有有效期的，其中面向连接协议在每次进行连接时都应更换密钥，而无连接协议可以在固定周期内使用固定密钥。</p>
<p>公钥加密体制的密钥管理涉及到密钥的分配、如何用“公钥体制”来分配对称密码体制所需的密钥。第一点不赘述。第二点有两种方法：简单分配（可能会被中间人攻击）、具有保密和认证的密钥分配（D-H协商、秘密分割、Shamir门限方案）</p>
<h1 id="密码协议"><a href="#密码协议" class="headerlink" title="密码协议"></a>密码协议</h1><p>数字承诺：Padersen数字承诺协议（也是基于离散对数问题）</p>
<p>不经意传输协议：A的秘密以0.5的概率传给B、协议执行完成后，B知道自己是否收到秘密，但A不知道B是否收到。</p>
<p>交互证明系统：零知识证明协议</p>

	  	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2023/06/10/hackersmani_1/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/03/02/AccManifesto/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	
	<!-- comment -->
	
		<section id="comments" style="margin:10px;padding:10px;background:#fff;">
		  <div id="vcomment" class="comment"></div> 
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
   var notify = 'true' == true ? true : false;
   var verify = 'false' == true ? true : false;
    window.onload = function() {
        new Valine({
            el: '.comment',
            notify: notify,
            verify: verify,
            app_id: "4UCwhumBRqjeYaJvb3Sx1URa-gzGzoHsz",
            app_key: "JrGdUqa7BaWGRmBkL8Swz2Ve",
            placeholder: "Just go go",
            avatar:"retro"
        });
    }
</script>

		</section>
	  

	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2023 Ariax
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
   </html>
