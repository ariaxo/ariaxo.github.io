<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EZ way to fetch HEXO after restoring operating system</title>
      <link href="/2024/03/25/fetch/"/>
      <url>/2024/03/25/fetch/</url>
      
        <content type="html"><![CDATA[<p>Just for recording in case this tragedy happens again.</p><h1 id="Backup-ssh-folder-important"><a href="#Backup-ssh-folder-important" class="headerlink" title="Backup .ssh folder (important)"></a>Backup .ssh folder (important)</h1><p>Basically it contains your RSA pub &amp; priv key and SSH config, which can be troublesome when get lost.</p><p>Also backup .gitnore file in your projects’ dir.</p><p>So most turorials on the internet suggest generating RSA keys locally (again) and copying them to github (again). However if you backup the files mentioned above, simply copying <code>.ssh</code> to the user’s dir works well. For SSH config in remote acc won’t disappear when the system is reinstalled.</p><h1 id="RE-Download-GIT-Nodejs-amp-HEXO"><a href="#RE-Download-GIT-Nodejs-amp-HEXO" class="headerlink" title="(RE)Download GIT, Nodejs &amp; HEXO"></a>(RE)Download GIT, Nodejs &amp; HEXO</h1><p>Not much to say, just encountered a bug where Nodejs’ autoinst was unable to write its dir to <code>PATH</code>, so I manually write it.</p><p>Better restart your pc after this.</p><p>And <code>npm install</code>, <code>hexo g; hexo s</code>. Done.</p><h1 id="Problematic-HEXO-D"><a href="#Problematic-HEXO-D" class="headerlink" title="Problematic HEXO D"></a>Problematic <code>HEXO D</code></h1><pre class="line-numbers language-none"><code class="language-none">fatal: detected dubious ownership in repository at &#39;D:&#x2F;blog&#x2F;blog&#x2F;.deploy_git&#39;&#39;D:&#x2F;blog&#x2F;blog&#x2F;.deploy_git&#39; is owned by:xxxxxxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MNE Python Notes</title>
      <link href="/2024/03/17/mne_notes/"/>
      <url>/2024/03/17/mne_notes/</url>
      
        <content type="html"><![CDATA[<h1 id="EEG-ANALYSIS-WITH-MNE"><a href="#EEG-ANALYSIS-WITH-MNE" class="headerlink" title="EEG ANALYSIS WITH MNE"></a>EEG ANALYSIS WITH MNE</h1><div class="container">  **Disclaimer**  <div class="disclaimer">    <p>This post includes codes extracted or modified from referenced articles for educational purposes. If there are any copyright issues, please contact the author for removal.</p>  </div></div><p><a href='https://mne.tools/stable/auto_tutorials/index.html'>Official tutorial</a></p><h3 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h3><p><a href='https://www.sensortips.com/featured/what-is-the-difference-between-an-ecg-eeg-emg-and-eog/'>ECG, EEG, EMG, EOG</a></p><p>MEG, STI</p><p>gradiometers, magnetometers</p><h2 id="Launch-MNE"><a href="#Launch-MNE" class="headerlink" title="Launch MNE"></a>Launch MNE</h2><pre class="line-numbers language-[shell]" data-language="[shell]"><code class="language-[shell]">anaconda navpowershellconda activate mnejupyter lab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Work-with-continuous-data"><a href="#Work-with-continuous-data" class="headerlink" title="Work with continuous data"></a>Work with continuous data</h2><h4 id="Processing-raws"><a href="#Processing-raws" class="headerlink" title="Processing raws"></a>Processing raws</h4><p>REF: </p><p>import needed packages:</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">import matplotlibimport pathlibimport mne<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>set storage location:</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">sample_data_dir &#x3D; mne.datasets.sample.data_path()# Convert to a pathlib.Path for more conveniencesample_data_dir &#x3D; pathlib.Path(sample_data_dir)sample_data_dir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then use <code>.plot()</code> to visualize them!</p><h4 id="Working-with-events"><a href="#Working-with-events" class="headerlink" title="Working with events"></a>Working with events</h4><p>REF: WORKLAB NOTEBOOK #1</p><p>Converting raw data into events, naming, and extracting them aims to enhance data comprehension and analysis</p><p>Extract events:</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">events &#x3D; mne.find_events(raw)event_id &#x3D; &#123;&#39;Auditory&#x2F;Left&#39;: 1,&#39;Auditory&#x2F;Right&#39;: 2,&#39;Visual&#x2F;Left&#39;: 3,&#39;Visual&#x2F;Right&#39;: 4,&#39;Smiley&#39;: 5,&#39;Button&#39;: 32&#125;len(events[events[:, 2] &#x3D;&#x3D; 32])len(events[events[:, 2]&#x3D;&#x3D;4])+len(events[events[:, 2]&#x3D;&#x3D;3])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Mark channels as bad:<br><code>raw.info['bads'&#125;+=['EEG 051']</code></p><p>Or just manually perform it after visualizing them.</p><h4 id="Crop-amp-Filter"><a href="#Crop-amp-Filter" class="headerlink" title="Crop &amp; Filter"></a>Crop &amp; Filter</h4><p>REF: WORKSHOP NOTEBOOK #1</p><p>Selecting specific portions of the raw data based on predefined criteria or parameters, such as time range, location, or data type, to extract relevant subsets for further analysis.</p><p>NOTE: It’s a diffrent process from “cleaning”.</p><p>Sample code: </p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">import matplotlib.pyplot as pltfig, ax &#x3D; plt.subplots(2)raw_eeg_cropped.plot_psd(ax&#x3D;ax[0], show&#x3D;False)raw_eeg_cropped_filtered.plot_psd(ax&#x3D;ax[1], show&#x3D;False)ax[0].set_title(&#39;PSD before filtering&#39;)ax[1].set_title(&#39;PSD after filtering&#39;)ax[1].set_xlabel(&#39;Frequency (Hz)&#39;)fig.set_tight_layout(True)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Output:<br><img src="/img/psd1.jpeg"><br><img src="/img/psd2.jpeg"></p><h2 id="BIDS-Brain-image-data-structure"><a href="#BIDS-Brain-image-data-structure" class="headerlink" title="BIDS(Brain image data structure)"></a>BIDS(Brain image data structure)</h2><p>Write raw data to BIDS:</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">raw.info[&#39;line_freq&#39;] &#x3D; 60subject_info &#x3D; &#123;&#39;birthday&#39;:(1996,10,1),&#39;sex&#39;:2,&#39;hand&#39;:3&#125;raw.info[&#39;subject_info&#39;] &#x3D; subject_inforaw.info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Reading BIDS data:</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">bids_root &#x3D; pathlib.Path(&#39;out_data&#x2F;sample_BIDS&#39;)bids_path &#x3D; mne_bids.BIDSPath(subject&#x3D;&#39;01&#39;,                          session&#x3D;&#39;01&#39;,                          task&#x3D;&#39;audiovisual&#39;,                          run&#x3D;&#39;01&#39;,                          datatype&#x3D;&#39;meg&#39;,                          root&#x3D;bids_root)raw &#x3D; mne_bids.read_raw_bids(bids_path)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EPOCH-amp-EVOKED-Uncontinuous-data"><a href="#EPOCH-amp-EVOKED-Uncontinuous-data" class="headerlink" title="EPOCH &amp; EVOKED - Uncontinuous data"></a>EPOCH &amp; EVOKED - Uncontinuous data</h2><p>REF: NOTEBOOK #3<br><a href='https://mp.weixin.qq.com/s/eJz5a1Up8fST0P1AcNs6Ig'>脑机接口社区 (Chinese)</a></p><p>EPOCH: Signals contracted from continuous EEG signals, divided by time spans. In MNE, EPOCH acts as a method marking continuous assets as time span assets.</p><p>To build EPOCH:</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">    # Firstly preprocess the raws    # Divided into events and thentmin &#x3D; -0.3tmax &#x3D; 0.5baseline &#x3D; (None, 0)epochs &#x3D; mne.Epochs(raw,                    events&#x3D;events,                    event_id&#x3D;event_id,            tmin&#x3D;tmin,                    tmax&#x3D;tmax,                    baseline&#x3D;baseline,                    preload&#x3D;True)epochs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">Output:Not setting metadata320 matching events foundSetting baseline interval to [-0.2996928197375818, 0.0] sApplying baseline correction (mode: mean)Created an SSP operator (subspace dimension &#x3D; 3)3 projection items activatedUsing data from preloaded Raw for 320 events and 481 original time points ...0 bad epochs droppedNumber of events320EventsAuditory&#x2F;Left: 72Auditory&#x2F;Right: 73Button: 16Smiley: 15Visual&#x2F;Left: 73Visual&#x2F;Right: 71Time range-0.300 – 0.499 sBaseline-0.300 – 0.000 s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Also we can select epochs based on experimental criterias</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">epochs[&#39;Right&#39;].copy().pick_types(meg&#x3D;False,eeg&#x3D;True).plot_image()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Remember to first build <code>events</code></p><p>EVOKED:  “Evoked Potential (EP)” refers to specific patterns of electrical potentials recorded from the nervous system, particularly specific areas of the brain, in humans or other animals, following stimuli such as flashes or pure tones. The potentials are usually low, thus it’s common practice to average them.</p><p>Creating EVOKED from EPOCHS:</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">evoked_auditory &#x3D; epochs[&#39;Auditory&#39;].average()evoked_visual &#x3D; epochs[&#39;Visual&#39;].average()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Reading EVOKED data:</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">evokeds &#x3D; mne.read_evokeds(fname&#x3D;pathlib.Path(&#39;out_data&#39;) &#x2F; &#39;evokeds_ave.fif&#39;)evokeds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Draw Global Field Power(GFP)</p><p>Draw EVOKED</p><h3 id="Epoched-data-cleaning"><a href="#Epoched-data-cleaning" class="headerlink" title="Epoched data cleaning"></a>Epoched data cleaning</h3><p>Same thing, preprocess raws first</p><p>Then reject artifacts</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">reject_criteria &#x3D; dict(mag&#x3D;3000e-15,     # 3000 fT                       grad&#x3D;3000e-13,    # 3000 fT&#x2F;cm                       eeg&#x3D;150e-6,       # 150 µV                       eog&#x3D;200e-6)       # 200 µVflat_criteria &#x3D; dict(mag&#x3D;1e-15,          # 1 fT                     grad&#x3D;1e-13,         # 1 fT&#x2F;cm                     eeg&#x3D;1e-6)           # 1 µVepochs.drop_bad(reject&#x3D;reject_criteria, flat&#x3D;flat_criteria)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SSP-amp-ICA"><a href="#SSP-amp-ICA" class="headerlink" title="SSP &amp; ICA"></a>SSP &amp; ICA</h4><p>REF: NOTEBOOK #4<br>Official tutorial</p><p>The following is basically…summery of the above processes</p><p>We load the raws into BIDS, crop &amp; filter and set events</p><p>finally we create projectors</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">bids_root &#x3D; pathlib.Path(&#39;out_data&#x2F;sample_BIDS&#39;)bids_path &#x3D; mne_bids.BIDSPath(subject&#x3D;&#39;01&#39;,                              session&#x3D;&#39;01&#39;,                              task&#x3D;&#39;audiovisual&#39;,                              run&#x3D;&#39;01&#39;,                              datatype&#x3D;&#39;meg&#39;,                              root&#x3D;bids_root)# MNE needs continuous data to work with, # so to create projecters we need to start with# raw data againraw &#x3D; mne_bids.read_raw_bids(bids_path)raw.load_data()raw.filter(l_freq&#x3D;0.1, h_freq&#x3D;40)ecg_projs, ecg_events &#x3D; mne.preprocessing.compute_proj_ecg(raw, n_grad&#x3D;1, n_mag&#x3D;1, n_eeg&#x3D;0,                                                           average&#x3D;True)eog_projs, eog_events &#x3D; mne.preprocessing.compute_proj_eog(raw, n_grad&#x3D;1, n_mag&#x3D;1,n_eeg&#x3D;1, average&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>And for ICA, we ceate EPOCHS and fit</p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">epochs_ica.infon_components &#x3D; 0.8  # Should normally be higher, like 0.999!!method &#x3D; &#39;picard&#39;max_iter &#x3D; 100  # Should normally be higher, like 500 or even 1000!!fit_params &#x3D; dict(fastica_it&#x3D;5)random_state &#x3D; 42ica &#x3D; mne.preprocessing.ICA(n_components&#x3D;n_components,                                                        method&#x3D;method,                            max_iter&#x3D;max_iter,                            fit_params&#x3D;fit_params,                            random_state&#x3D;random_state)ica.fit(epochs_ica)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">OUTPUT:MethodpicardFit parametersfastica_it&#x3D;5max_iter&#x3D;100Fit82 iterations on epochs (201920 samples)ICA components28Available PCA components364Channel typesmag, grad, eegICA components marked for exclusion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(Output was in table format but im too lazy)</p><p>Then we can detect patterns and… plot scores or some</p><p>Try overlay to see the cleaning process really works:<br><img src="/img/overlay.png"></p><pre class="line-numbers language-[python]" data-language="[python]"><code class="language-[python]">epochs_cleaned&#x3D;ica.apply(epochs.copy())epochs_cleaned.plot()epochs.plot()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Time-Frequency"><a href="#Time-Frequency" class="headerlink" title="Time Frequency"></a>Time Frequency</h2><h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《黑客宣言》 1. 摘要 --Mckenzie Wark</title>
      <link href="/2023/06/10/hackersmani_1/"/>
      <url>/2023/06/10/hackersmani_1/</url>
      
        <content type="html"><![CDATA[<p>译注：斜体（在本站默认字体里以“//”标识）意味着此处为名词ABSTRACTION。（没有校队）</p><p>关于hack：中文里似乎没有意义相近的词语，根据语境会分别翻译成黑客（行为）、破解、骇等，更多时候直译成hack。</p><p>粗体只是译者有感触的部分——这就是一份随意的、粗略的、个人的翻译。</p><p>[001]</p><p>一个双重性，<em>抽象</em>的双重性，在世界游荡。国家、军队、公司和社群的命运取决于它。所有相互争斗的阶级，无论是统治阶级还是被统治阶级，都崇敬它，但又害怕它。我们的世界，是一个盲目地交叉着手指涉足未知的世界。</p><p>[002]</p><p>所有阶级都害怕这个世界无情的抽象化，然而它们的命运却仍然依赖于它。但有一个阶级例外：黑客阶级。我们是<em>抽象</em>的黑客。我们从原数据中挖掘出新概念、新感知、新感觉。无论我们破解的是编程语言、诗性语言、数学还是音乐，曲线或色彩，我们都是创造新世界的抽象者。无论我们以研究员、作家、艺术家、生物学家、化学家、音乐家、哲学家还是程序员的身份出现，每一个主体性都只是一个逐渐意识到自己身份的阶级的碎片。</p><p>[003]</p><p>然而，我们并不完全知道自己是谁。这就是为什么这本书试图阐明我们的起源、目标和利益。一份黑客宣言：并不是唯一的宣言，因为黑客的本质就是与他人不同，甚至与随时变化的自己而不同。选择hack就是选择不同。一份黑客宣言不能代表拒绝被代表的事物。</p><p>[004]</p><p>黑客创造了新事物进入世界的可能性。并不总是伟大的事物，甚至不一定是好的事物，但它们是新的事物。在艺术、科学、哲学和文化领域，在任何可以收集数据、提取信息并通过这些信息为世界创造新可能性的知识生产中，都有黑客从旧的事物中创造出新的事物。虽然我们创造了这些新世界，但我们并不拥有它们。我们创造的东西被抵押给了其他人，被抵押给了其他人的利益，被抵押给了垄断创造我们独自发现的世界的手段的国家和公司。我们不拥有我们所生产的东西——我们被它们所拥有。</p><p>[005]</p><p>黑客利用他们的知识和智慧来维持他们的自主权。有些人拿钱离开（我们必须与我们的妥协生活）。有些人拒绝妥协（我们尽力而为地生活）。通常情况下，那些选择其中一条道路的人会对选择另一条道路的人心存怨恨。一部分人怨恨他们所缺乏的繁荣，另一部分人怨恨他们所缺乏的自由，无法自由地对世界进行hack。黑客阶级所无法把握的是一种更抽象的表达：我们作为一个阶级的利益，以及这种利益如何与世界上其他人的利益相遇。</p><p>[006]<br>黑客不是随波逐流者（joiner）。我们通常不愿意淹没自己的独特性。时代需要的是一种集体的hack，以实现基于差异的阶级利益，而不是强制性的统一。黑客是一个阶级，但是一个抽象的阶级。一个制造<em>抽象</em>的阶级，也是一个被抽象化的阶级。将黑客抽象为一个阶级就是抽象出阶级概念本身。黑客阶级的口号不是“全世界的工人团结起来”，而是“全世界的机制解开”（the workings of the world untied）。</p><p>[007]</p><p>在<em>抽象</em>统治的地方，<em>抽象</em>变得具体。在各处，<em>抽象</em>的直线和纯粹的曲线沿着复杂但高效的向量规范事物。然而，尽管在教育中教授给人们的是如何用抽象物产生成果，对黑客阶级最有用的知识是关于抽象物本身是如何产生。德勒兹（Deleuze）说过：“抽象物不能解释什么，它们自身必须被解释。”</p><p>[008]</p><p><em>抽象</em>可以被发现或产生，可以是物质的或非物质的，但<em>抽象</em>是每个hack所产生和肯定的东西。抽象化是在其中可以将原本不同和无关的事物引入许多可能关系的平面。抽象化是自然虚拟性的表达，揭示其可能性的某个实例，从无限关联性中实现一种关系，展示多样性。</p><p>[009]</p><p>历史是<em>抽象</em>的生产和生产的<em>抽象</em>。使得生命在一个又一个时代中有所不同的是将新的<em>抽象</em>模式应用于从必然性中获得自由的任务。历史是虚拟变为实际，一个接一个的hack。历史是自然的累积性质的差异化，就像被hack一样。</p><p>[010]</p><p>从自然的<em>抽象</em>中产生了生产力，并产生了超出生存必需的剩余。在这个超出必要的剩余的扩大中，产生了一种不断创造hack的能力，一次又一次地产生进一步的抽象、进一步的生产力、进一步从必然性中解脱出来的可能性。但是，对自然的hack、对剩余的生产，并不能使我们自由。一次又一次地，一个统治阶级出现，控制着超出最基本必需的剩余，并对那些生产这种摆脱必然性手段的人民强加新的必需。</p><p>[011]</p><p>我们这个时代的不同之处在于，一个长期处于想象中的新世界的可能性出现在地平线上——一个摆脱必然性的世界。<strong>抽象的产生已经达到了一个临界点，在这个临界点上，它可以彻底打破将hack牢牢束缚于过时和倒退的阶级利益的枷锁。</strong>德波（Debord）曾说：“世界已经拥有了一个时间的梦想，现在必须拥有这个梦想的意识，以真正地生活它。”</p><p>[012]</p><p>发明是需求之母。虽然所有国家都依赖于<em>抽象</em>来生产财富和权力，但任何给定国家的统治阶级与以新形式产生<em>抽象</em>的生产之间存在着不稳定的关系。统治阶级始终试图控制创新，并将其转化为自己的目的，剥夺黑客对其创作的控制权，从而否认整个世界管理自己发展的权利。</p><p>[013]</p><p>新抽象的产生总是在那些通过hack而被隔离的人中进行。<strong>我们这些通过从旧世界中创造新世界的方式进行hack的人，在这个过程中不仅成为孤立的陌生人，而且成为一个独特的阶级。</strong>虽然我们意识到自己作为一个团体的独特存在，作为程序员、艺术家、作家、科学家或音乐家，但我们很少将这些方式仅仅看作是阶级经验的碎片。极客和怪人通过被其他人排斥来成为他们自己。我们一起形成一个阶级，一个阶级尚未将自己作为自己存在，并为自己而破解。</p><p>[014]</p><p>正是通过抽象，虚拟得以被识别、产生和释放。虚拟不仅是存在于物质中的潜力，更是<em>潜力</em>的潜力。hack就是将<em>抽象</em>应用于信息，并表达出超越必然性的新世界的可能性。</p><p>[015]</p><p>所有的<em>抽象</em>都是对自然的抽象。<em>抽象</em>释放了物质世界的潜力。然而，抽象依赖于物质世界最奇特的特质——信息。信息可以独立于特定的物质形态存在，但不能没有任何物质形态存在。它既是物质的又是非物质的。hack依赖于自然的物质特性，但又发现了与特定的物质形态无关的东西。它既是物质的又是非物质的。它发现了物质的非物质虚拟性，以及它的信息特性。</p><p>[016]</p><p><em>抽象</em>始终是对自然的<em>抽象</em>，一个创造出自然的双重性、第二性质的过程，一个人类存在的空间，其中集体生活与自己的产物共存，并将其生产的环境视为自然。</p><p>[017]</p><p>土地是从一种自然资源中脱离出去的东西，是自然的生产潜力以财产形式呈现的一个方面。资本是从一种土地资源中脱离出来的东西，是土地的生产潜力以财产形式呈现的一个方面。信息是一种从已经脱离土地的资本中脱离出来的东西。一个双重性的双重性。一个超越资本的进一步<em>抽象</em>过程，但再次以财产形式产生了它自己的独立存在。</p><p>[018]</p><p>正如土地作为生产资源的发展为其以资本形式的<em>抽象</em>创造了历史进步一样，资本的发展也为信息进一步<em>抽象</em>提供了历史进步，以“知识产权”的形式呈现。在传统社会中，土地、资本和信息与特定的社会或地区权力通过习俗或世袭关系紧密相连。<em>抽象</em>从古老的封建残骸中解放出来的是这些资源的解放，基于一种更抽象的财产形式，即普遍的私有财产权。这种普遍的<em>抽象</em>形式首先包括土地，然后是资本，现在是信息。</p><p>[019]</p><p>当财产的<em>抽象</em>释放出生产资源时，同时产生了一个阶级分裂。私有财产建立了一个拥有土地的牧场主阶级（pastoralist class），以及被剥夺土地的农民阶级。在将人民从传统的共同土地权利中驱逐出来的私有财产的抽象中，它创造了一个被剥夺的阶级，他们成为工人阶级，因为他们被拥有生产资料的资本家阶级所雇佣。这个工人阶级成为第一个认真考虑推翻阶级统治观念的阶级。它在这一历史任务上失败到了财产形式尚未足够抽象，无法释放潜在于抽象的生产能量中的无阶级性的虚拟性的程度。</p><p>[020]</p><p>总是黑客创造新的抽象。随着黑客阶级的出现，新的抽象产生速度加快。将知识产权视为一种财产形式——这本身就是一个抽象，一种法律上的hack——创造了一类知识产权创造者。但是，这个阶级仍然为了另一个阶级的利益而劳动，它自己的利益受到其它阶级的支配。随着私有财产的抽象被扩展到信息领域，它产生了黑客阶级作为一个阶级，一个能够将其在抽象方面的创新变为财产形式的阶级。与农民和工人不同，黑客尚未完全被剥夺他们的财产权利，但仍然必须将他们的<em>抽象</em>能力出售给拥有生产手段的阶级，即介导阶级（The vectoralist class）——我们这个时代的新兴统治阶级。</p><pre><code>译注：在这里，&quot;vector&quot;是一种描述信息传递和流动的隐喻，而&quot;vectoralist class&quot;指的就是控制和利用信息流、数字化资本和知识产权的阶级，如大型媒体、网络公司、数据机构等。与传统的资本主义阶级不同，&quot;vectoralist class&quot;通过控制信息流而获得利润和权力，而不仅仅是通过拥有物质资源或生产手段。此处翻译感谢功能主义委员会。</code></pre><p>[021]</p><p>介导阶级进行了激烈的斗争，剥夺黑客们的知识产权。专利和版权最终落入的不是它们的创造者手中，而是拥有实现这些<em>抽象</em>价值手段的介导阶级手中。介导阶级努力垄断抽象。对于介导阶级来说，“政治意味着通过沟通、控制和指挥的战略手段，对知识产权实现绝对控制。”* 黑客们发现自己既在个体层面上被剥夺，也在阶级层面上被剥夺。</p><p>[022]</p><p>随着介导阶级巩固其对实现知识产权价值手段的垄断地位，它越来越将黑客阶级视为阶级对手。黑客们开始与介导阶级抗争，反对后者为获取黑客们共同创造的信息而勒索的高额费用，尽管这些信息归介导阶级所有。黑客们开始反抗将<em>抽象</em>商品化并转变为介导阶级的私有财产的特定形式。作为一个阶级，黑客们开始意识到他们的阶级利益最好通过争取解放<em>抽象</em>的生产来表达，不仅是从这种或那种财产形式的特定束缚中解放，而是从财产形式本身进行<em>抽象</em>。</p><p>[023]</p><p>黑客们必须与工人、农民以及世界上所有的生产者团结起来，解放生产和创新资源，<strong>摆脱稀缺的神话。创造新形式的组织已经迫在眉睫，以引导世界摆脱商品化剥削而导致的毁灭。</strong>我们时代最伟大的hack可能是建立自由集体表达的组织形式，从此以后，<em>抽象</em>为人民服务，而不是人民为统治阶级服务。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数论与密码学手册</title>
      <link href="/2023/05/29/crypto/"/>
      <url>/2023/05/29/crypto/</url>
      
        <content type="html"><![CDATA[<p><a href=https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%AE%97%E6%95%B8>mod（%）运算（建议应当相当熟悉这个链接以及相关链接的内容）</a></p><p>笔者正在恶补数学……</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><!-- vscode-markdown-toc --><ul><li><ol><li><a href="#">质数/素数</a></li></ol></li><li><ol start="2"><li><a href="#Euclideanalgorithm">欧几里得算法（Euclidean algorithm）</a></li></ol></li><li><ol start="3"><li><a href="#-1">费马小定理</a></li></ol></li><li><ol start="4"><li><a href="#-1">拓展欧几里得算法</a></li></ol><ul><li>4.1. <a href="#-1">求逆元</a></li></ul></li><li><ol start="5"><li><a href="#-1">贝祖等式</a></li></ol></li><li><ol start="6"><li><a href="#-1">中国剩余定理</a></li></ol></li><li><ol start="7"><li><a href="#One-TimePad">一次一密（One-Time Pad）：</a></li></ol></li><li><ol start="8"><li><a href="#-1">*分组密码</a></li></ol></li><li><ol start="9"><li><a href="#-1">线性反馈移位寄存器</a></li></ol></li><li><ol start="10"><li><a href="#RC4">RC4算法</a></li></ol><ul><li>10.1. <a href="#SHA-1:write-ups">编程”实现”SHA-1: 只是demo</a></li></ul></li><li><ol start="11"><li><a href="#RSADSA">RSA与DSA算法</a></li></ol><ul><li>11.1. <a href="#RSA">编程“实现”RSA</a></li></ul></li><li><ol start="12"><li><a href="#Diffie-HellmanElgamal">Diffie-Hellman &amp; Elgamal</a></li></ol></li><li><ol start="13"><li><a href="#-1">数字签名/证书</a></li></ol></li><li><ol start="14"><li><a href="#-1">椭圆曲线算法</a></li></ol></li></ul><!-- vscode-markdown-toc-config    numbering=true    autoSave=true    /vscode-markdown-toc-config --><!-- /vscode-markdown-toc --><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="1-质数-素数"><a href="#1-质数-素数" class="headerlink" title="1. 质数/素数"></a>1. <a name=''></a>质数/素数</h2><p>只有1与本身两个因数的正整数。</p><p>6.3注：大整数分解困难问题是RSA算法的基础。另还有基于离散对数困难问题的Diffie-Hellman密钥交换协议、Elgamal加密以及DSA算法、基于椭圆曲线上离散对数困难问题的椭圆曲线密码体制。</p><p>整除的概念（拓展到多项式即为环）</p><p>素数的分布（黎曼猜想）、无限性证明（反证法）</p><h2 id="Eratoshenes-sieve"><a href="#Eratoshenes-sieve" class="headerlink" title="Eratoshenes sieve"></a>Eratoshenes sieve</h2><p>例：找出小于或等于30的所有素数。</p><p>步骤1：创建一个包含从2到30的所有整数的列表。</p><pre class="line-numbers language-none"><code class="language-none">2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>步骤2：从列表中选择第一个数，也就是2，将2的倍数从列表中移除。</p><pre class="line-numbers language-none"><code class="language-none">2 3 5 7 9 11 13 15 17 19 21 23 25 27 29<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>步骤3：选择下一个未被标记的数，也就是3，将3的倍数从列表中移除。</p><pre class="line-numbers language-none"><code class="language-none">2 3 5 7 11 13 17 19 23 25 29<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>步骤4：继续这个过程，选择下一个未被标记的数，直到达到了30的平方根（即5），因为在那之后的数都已经被标记或移除了。</p><p>步骤5：剩下的未被标记的数就是小于或等于30的所有素数。</p><p>E seive是确定性方法，而Miller Rabin素性检验是概率性方法。</p><h2 id="2-欧几里得算法（Euclidean-algorithm）"><a href="#2-欧几里得算法（Euclidean-algorithm）" class="headerlink" title="2. 欧几里得算法（Euclidean algorithm）"></a>2. <a name='Euclideanalgorithm'></a>欧几里得算法（Euclidean algorithm）</h2><p>我的理解中欧几里得算法即为，任意整数都可以被任意正整数线性表示，即a = q*b+r</p><p>欧几里得算法最大的应用是计算两个整数最大公约数（GCD）</p><blockquote><p>例如，我们要计算 72 和 30 的最大公约数：<br>a = 72，b = 30。<br>72 除以 30 得到商 2 和余数 12。<br>12 不等于 0，所以将 30 的值赋给 a，将 12 的值赋给 b。<br>a = 30，b = 12。<br>30 除以 12 得到商 2 和余数 6。<br>6 不等于 0，所以将 12 的值赋给 a，将 6 的值赋给 b。<br>a = 12，b = 6。<br>12 除以 6 得到商 2 和余数 0。<br>余数为 0，所以最大公约数为 6。</p></blockquote><p>而拓展欧几里得算法中GCD（a，b）也可以被a，b线性表示，即GCD（a，b）= s<em>a + t</em>b</p><h2 id="欧拉函数与欧拉定理"><a href="#欧拉函数与欧拉定理" class="headerlink" title="欧拉函数与欧拉定理"></a>欧拉函数与欧拉定理</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0</a></p><p>整数m＞1，（a，m）＝1，则a^E(m)与1同模m</p><h2 id="3-费马小定理"><a href="#3-费马小定理" class="headerlink" title="3. 费马小定理"></a>3. <a name='-1'></a>费马小定理</h2><p>如果 p 是一个质数，a 是任意不可被 p 整除的整数，则有：</p><pre class="line-numbers language-none"><code class="language-none">a^(p-1) ≡ 1 (mod p)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，^ 表示乘方运算，≡ 表示模运算的等价关系，即两边模 p 后的结果相等。</p><p>费马小定理的一个直接推论是，如果 p 是一个质数，a 是任意整数，则有：</p><pre class="line-numbers language-none"><code class="language-none">a^p ≡ a (mod p)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是反之，满足费马小定理的数不一定是素数。参见<a href=https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E4%BC%AA%E7%B4%A0%E6%95%B0>费马伪素数</a>。</p><h2 id="4-拓展欧几里得算法"><a href="#4-拓展欧几里得算法" class="headerlink" title="4. 拓展欧几里得算法"></a>4. <a name='-1'></a>拓展欧几里得算法</h2><p>拓展欧几里得算法的基本思想是从最后一步欧几里得算法开始逆向推导，通过反复应用欧几里得算法的辗转相除过程，同时更新贝祖等式的系数。具体步骤如下：</p><blockquote><p>初始化：令 a0 = a，b0 = b，x0 = 1，y0 = 0，x1 = 0，y1 = 1。<br>迭代计算：通过连续应用欧几里得算法的辗转相除过程，更新 a、b 和 x、y 的值，直到余数为 0。计算商和余数：q = a[i-1] // b[i-1]，r = a[i-1] % b[i-1]。<br>更新 a、b：a[i] = b[i-1]，b[i] = r。<br>更新 x、y：x[i] = x[i-2] - q * x[i-1]，y[i] = y[i-2] - q * y[i-1]。<br>输出结果：最大公约数为 b[n-1]，x[n-1] 和 y[n-1] 分别是贝祖等式 ax + by = gcd(a, b) 中的系数。</p></blockquote><p>拓展欧几里得算法在密码学中常用于求解<strong>模逆元</strong>的问题，即找到一个数的乘法逆元（模某个数的余数下的倒数）。</p><h3 id="4-1-求逆元"><a href="#4-1-求逆元" class="headerlink" title="4.1. 求逆元"></a>4.1. <a name='-1'></a>求逆元</h3><h2 id="5-贝祖等式"><a href="#5-贝祖等式" class="headerlink" title="5. 贝祖等式"></a>5. <a name='-1'></a>贝祖等式</h2><p>对于任意两个整数 a 和 b，存在整数 x 和 y，使得它们满足以下等式：</p><pre class="line-numbers language-none"><code class="language-none">ax + by &#x3D; gcd(a, b)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，gcd(a, b) 表示 a 和 b 的最大公约数。</p><p>相关阅读：<a href=https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B>线性同余方程</a></p><h2 id="6-中国剩余定理"><a href="#6-中国剩余定理" class="headerlink" title="6. 中国剩余定理"></a>6. <a name='-1'></a>中国剩余定理</h2><p>中国剩余定理的一般形式如下：</p><p>给定一组正整数 m₁, m₂, …, mₙ 两两互质，以及任意的整数 a₁, a₂, …, aₙ，中国剩余定理说明存在一个整数 x，满足以下条件：</p><p>x ≡ a₁ (mod m₁)</p><p>x ≡ a₂ (mod m₂)</p><p>…</p><p>x ≡ aₙ (mod mₙ)</p><p>中国剩余定理可以找到一个满足多个模同余条件的整数。</p><p>以下为一个例子</p><img src=/img/crt.jpg><h1 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h1><p>对称密钥加密是一种加密技术，其中使用相同的密钥（称为对称密钥）用于加密和解密数据。发送方使用密钥将明文（原始数据）转换为密文（加密后的数据），而接收方使用相同的密钥将密文转换回明文。</p><p>在对称密钥加密中，加密和解密过程使用相同的密钥，因此需要确保密钥的保密性。如果第三方获得了密钥，他们就可以轻松地解密和访问加密的数据。</p><h2 id="7-一次一密（One-Time-Pad）："><a href="#7-一次一密（One-Time-Pad）：" class="headerlink" title="7. 一次一密（One-Time Pad）："></a>7. <a name='One-TimePad'></a>一次一密（One-Time Pad）：</h2><p>一次一密是一种理论上具有绝对安全性的加密方法。它使用与明文长度相等的随机密钥进行异或运算，生成密文。密钥只使用一次，然后丢弃，因此称为一次一密。解密时，使用相同的密钥对密文进行异或运算，可以得到原始的明文。</p><p>OTP可以保证<strong>Perfect Secrecy</strong>。<br>联想：HTTPS 协议中的完美前向保密性（Perfect Forward Secrecy）是指在通信过程中，即使长期主密钥（long-term master key）被攻击者获得，之前的通信记录也无法被解密。在 HTTPS 中，完美前向保密性通过使用临时的会话密钥（session key），每次会话都生成一个新的临时密钥，用于加密通信。即使攻击者获取了主密钥，他们也无法通过该主密钥解密之前的通信记录，因为会话密钥已经发生了变化。</p><p>与PFS方法不同，OTP方法在实践中并不常用。</p><h2 id="8-分组密码"><a href="#8-分组密码" class="headerlink" title="8. *分组密码"></a>8. <a name='-1'></a>*分组密码</h2><p>扩散与混淆<br>运行模式：*0+<br>OFB、CFB、CBC与ECB</p><h3 id="Feistel密码结构"><a href="#Feistel密码结构" class="headerlink" title="Feistel密码结构"></a>Feistel密码结构</h3><h3 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h3><p>明文密文分组长度64位，密钥64位（有效56位）</p><blockquote><p>在 DES 的 ECB 模式中，如果在密文［1］分组中有一个错误，解密后仅相应的明文［2］分组受到影响然而在 CBC 模式中，将有错误传播。C1中的一个错误明显地将影响到 P1和P2的结果<br>(1)P2后的分组是否受到影响？<br>（2）设加密前的明文分组P1中有1比特的错误，问这一错误将在多少个密文分组中传播？<br>对接收者产生什么影响？</p></blockquote><img src="/img/des1.jpg"><p>** DES的解密变换是加密变换的逆</p><img src="/img/des2.jpg"><img src="/img/des3.jpg"><p><strong>DES算法中的轮结构与轮函数</strong>：16轮迭代轮函数共有8个s盒，其中每个i为6bit👉o为4bit。</p><p>*S盒如何将六位数据转换成4位：<br>例如，原始数据{1 0011 1 } ，取头尾数据11，十进制👉3即为行数</p><p>取中间数据0011，十进制👉3即为列数</p><p>在对应DES的S盒中查找就可以{十进制2👉0010                                                                                                                                                                                    }</p><p>二/三重DES</p><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><p>{此处需要群/域的基础}，见<br><a href="https://zh.wikipedia.org/wiki/%E7%BE%A4">https://zh.wikipedia.org/wiki/%E7%BE%A4</a> 中的“定义”，<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F_(%E6%95%B0%E5%AD%A6)">https://zh.wikipedia.org/wiki/%E5%9F%9F_(%E6%95%B0%E5%AD%A6)</a></p><img src="/img/aes1.jpg"><img src="/img/aes2.jpg"><img src="/img/aes3.jpg"><img src="/img/aes4.jpg"><p>*AES算法的分组大小128位，三种密码标准：128、256、192（位）</p><p>**AES算法的过程：AddRoundKey👉SubstituteBytes👉ShiftRows👉MixColumns<br><img src="/img/aes5.jpg"></p><h3 id="SM4算法"><a href="#SM4算法" class="headerlink" title="SM4算法"></a>SM4算法</h3><p>分组长度128bit=密钥长度</p><h1 id="流加密"><a href="#流加密" class="headerlink" title="流加密"></a>流加密</h1><h2 id="9-线性反馈移位寄存器"><a href="#9-线性反馈移位寄存器" class="headerlink" title="9. 线性反馈移位寄存器"></a>9. <a name='-1'></a>线性反馈移位寄存器</h2><p>线性反馈移位寄存器（Linear Feedback Shift Register，简称LFSR）是一种在计算机科学和密码学中常用的序列发生器。它是由多个寄存器和一组反馈函数组成的，通过对寄存器中的位进行移位和异或操作来生成一个伪随机的二进制序列。</p><p>以下为一个例子：</p><h2 id="10-RC4算法"><a href="#10-RC4算法" class="headerlink" title="10. RC4算法"></a>10. <a name='RC4'></a>RC4算法</h2><h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>引入哈希函数主要是为了保证数据完整性（这与隐私是不同的）</p><p>哈希函数是一种将输入数据（消息）转换为固定长度输出（哈希值）的函数。</p><ol><li><p>抗原象性（Preimage Resistance）：对于给定的哈希值，很难找到一个与之对应的输入消息。也就是说，对于任意给定的哈希值，计算出其对应的输入消息应该是困难的。这意味着哈希函数应该是单向的，不可逆的。</p></li><li><p>抗第二原像性（Second Preimage Resistance）：给定一个输入消息，很难找到另一个不同的输入消息，使得它们具有相同的哈希值。也就是说，对于已知的输入消息，计算出与之具有相同哈希值的其他输入消息应该是困难的。</p></li><li><p>抗碰撞性（Collision Resistance）：很难找到两个不同的输入消息，使得它们具有相同的哈希值。也就是说，计算出两个具有相同哈希值的不同输入消息应该是困难的。</p></li><li><p>生日攻击（Birthday Attack）：生日攻击是一种特殊的攻击方式，利用生日悖论的原理，在较短的时间内找到两个具有相同哈希值的输入消息的概率较高。哈希函数应该抵抗生日攻击，即使在较长的时间内，找到具有相同哈希值的输入消息的概率也应该非常低。</p></li></ol><blockquote><p>生日攻击利用了概率学中的生日悖论，即在一组人中，只需要有23个人，就存在两个人生日相同的概率超过一半。类似地，在哈希函数中，由于输出空间的大小有限，当输入消息的数量足够大时，存在相同哈希值的输入消息的概率变得非常高。</p></blockquote><blockquote><p>为了抵抗生日攻击，通常的做法是使用更长的哈希值，例如SHA-256（256位哈希值）或SHA-3（Keccak）系列。这增加了哈希值的空间大小，降低了相同哈希值的概率。此外，还有一些专门设计的哈希函数，如HMAC（Hash-based Message Authentication Code）和SHA-3家族中的SHAKE函数，用于抵御生日攻击。</p></blockquote><p>总结来说，即为产生MAC、传输MAC、验证MAC</p><h3 id="10-1-编程”实现”SHA-1-见write-ups吧"><a href="#10-1-编程”实现”SHA-1-见write-ups吧" class="headerlink" title="10.1. 编程”实现”SHA-1: 见write-ups吧"></a>10.1. <a name='SHA-1:write-ups'></a>编程”实现”SHA-1: 见write-ups吧</h3><p>如何利用哈希函数构造MAC？</p><h1 id="公钥密码"><a href="#公钥密码" class="headerlink" title="*公钥密码"></a>*公钥密码</h1><p>这部分需要详细学习（尤其是RSA非常重要）</p><p>对称密码体制缺乏开放的系统，依赖信道的可靠性、密钥管理困难，用户量增加时密钥空间急剧增大、难以实现抗抵赖。</p><p>公钥密码使用两个密钥：公开密钥与秘密密钥，加密解密非对称。模型：KeyGen()-&gt;(pk,sk);Enc(pk,m)-&gt;c;Dec(sk,c)-&gt;m</p><h2 id="11-RSA与DSA算法"><a href="#11-RSA与DSA算法" class="headerlink" title="11. RSA与DSA算法"></a>11. <a name='RSADSA'></a>RSA与DSA算法</h2><p>RSA证明方法：</p><p>安全性基于大整数分解：RSA的安全性基于大整数分解的困难性。证明方法是通过选择两个大素数 p 和 q，并计算它们的乘积 n = p * q。然后选择一个与 (p-1)(q-1) 互质的整数 e 作为公钥指数，以及计算出满足 (d * e) mod ((p-1)(q-1)) = 1 的私钥指数 d。公钥是 (n, e)，私钥是 (n, d)。</p><p>RSA的安全性取决于大整数分解的困难性，即从 n 中分解出 p 和 q 的困难性。大整数分解是一个耗时的计算问题，尚未发现有效的算法可以在可接受的时间内分解大素数的乘积。</p><img src="/img/rsa1.jpg"><h3 id="11-1-编程“实现”RSA"><a href="#11-1-编程“实现”RSA" class="headerlink" title="11.1. 编程“实现”RSA"></a>11.1. <a name='RSA'></a>编程“实现”RSA</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 生成RSA密钥对function generateRSAKeyPair() &#123;  var keySize &#x3D; 2048; &#x2F;&#x2F; 密钥大小  var e &#x3D; new BigInteger(&quot;65537&quot;); &#x2F;&#x2F; 公钥指数  var p &#x3D; BigInteger.probablePrime(keySize &#x2F; 2, rng); &#x2F;&#x2F; 随机生成素数 p  var q &#x3D; BigInteger.probablePrime(keySize &#x2F; 2, rng); &#x2F;&#x2F; 随机生成素数 q  var n &#x3D; p.multiply(q); &#x2F;&#x2F; 计算 n &#x3D; p * q  var phi &#x3D; p.subtract(1).multiply(q.subtract(1)); &#x2F;&#x2F; 计算 φ(n) &#x3D; (p - 1) * (q - 1)  var d &#x3D; e.modInverse(phi); &#x2F;&#x2F; 计算私钥指数 d &#x3D; e^(-1) mod φ(n)  var publicKey &#x3D; &#123; e: e, n: n &#125;; &#x2F;&#x2F; 公钥 (e, n)  var privateKey &#x3D; &#123; d: d, n: n &#125;; &#x2F;&#x2F; 私钥 (d, n)  return &#123; publicKey: publicKey, privateKey: privateKey &#125;;&#125;&#x2F;&#x2F; RSA加密function rsaEncrypt(plaintext, publicKey) &#123;  var message &#x3D; new BigInteger(plaintext); &#x2F;&#x2F; 将明文转换为大整数  var e &#x3D; publicKey.e;  var n &#x3D; publicKey.n;  var ciphertext &#x3D; message.modPow(e, n); &#x2F;&#x2F; 加密操作：c &#x3D; m^e mod n  return ciphertext.toString();&#125;&#x2F;&#x2F; RSA解密function rsaDecrypt(ciphertext, privateKey) &#123;  var c &#x3D; new BigInteger(ciphertext); &#x2F;&#x2F; 将密文转换为大整数  var d &#x3D; privateKey.d;  var n &#x3D; privateKey.n;  var plaintext &#x3D; c.modPow(d, n); &#x2F;&#x2F; 解密操作：m &#x3D; c^d mod n  return plaintext.toString();&#125;&#x2F;&#x2F; 示例用法var plaintext &#x3D; &quot;Hello, RSA!&quot;;var keyPair &#x3D; generateRSAKeyPair();var publicKey &#x3D; keyPair.publicKey;var privateKey &#x3D; keyPair.privateKey;var ciphertext &#x3D; rsaEncrypt(plaintext, publicKey);console.log(&quot;Ciphertext:&quot;, ciphertext);var decryptedText &#x3D; rsaDecrypt(ciphertext, privateKey);console.log(&quot;Decrypted Text:&quot;, decryptedText);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="DSA证明方法："><a href="#DSA证明方法：" class="headerlink" title="DSA证明方法："></a>DSA证明方法：</h2><p>安全性基于离散对数问题：DSA的安全性基于离散对数问题的困难性。证明方法是通过选择一个大素数 p，并选择一个模 p 的生成元 g。然后生成一个私钥 x，满足 0 &lt; x &lt; p-1。计算公钥 y = g^x mod p。公钥是 (p, g, y)，私钥是 x。</p><p>DSA的安全性取决于离散对数问题的困难性，即计算 g^x mod p 中的 x 的困难性。离散对数问题是一个复杂的计算问题，在<strong>合理的</strong>时间内计算出离散对数是困难的。</p><h2 id="12-Diffie-Hellman-amp-Elgamal"><a href="#12-Diffie-Hellman-amp-Elgamal" class="headerlink" title="12. Diffie-Hellman &amp; Elgamal"></a>12. <a name='Diffie-HellmanElgamal'></a>Diffie-Hellman &amp; Elgamal</h2><p>Diffie-Hellman &amp; Elgamal 也都基于数论中的<strong>离散对数问题</strong></p><p>相关阅读：<a href="https://zhuanlan.zhihu.com/p/523658036">https://zhuanlan.zhihu.com/p/523658036</a></p><h2 id="13-数字签名-证书"><a href="#13-数字签名-证书" class="headerlink" title="13. 数字签名/证书"></a>13. <a name='-1'></a>数字签名/证书</h2><p>消息认证（上文哈希）保护通信免受第三方攻击，但不能防止通信中另一方的欺骗和伪造</p><p>几个点：RSA/DSA数字签名算法、Elgamal数字签名体制、Schnorr签名体制</p><h2 id="14-椭圆曲线算法ECC"><a href="#14-椭圆曲线算法ECC" class="headerlink" title="14. 椭圆曲线算法ECC"></a>14. <a name='-1'></a>椭圆曲线算法ECC</h2><p>RSA、Elgamal为了保障安全性，常常采用长度很大的密钥，而椭圆密码体系可以用更小的尺寸得到同样的安全性。</p><p>总结公钥密码：公钥密码解决了对称密码“密钥管理麻烦、开放性差”的缺点，但这不意味著公钥密码的出现使对称密码“过时”了，也不意味着公钥密码体系更安全。同时，公钥密码加密解密速度较慢。</p><h1 id="密钥管理与分配"><a href="#密钥管理与分配" class="headerlink" title="密钥管理与分配"></a>密钥管理与分配</h1><p>最后说下这个，单钥加密体制（也就是对称加密体制）密钥分配的基本方法根据有无密钥分配中心KDC分为两种，密钥会话是有有效期的，其中面向连接协议在每次进行连接时都应更换密钥，而无连接协议可以在固定周期内使用固定密钥。</p><p>公钥加密体制的密钥管理涉及到密钥的分配、如何用“公钥体制”来分配对称密码体制所需的密钥。第一点不赘述。第二点有两种方法：简单分配（可能会被中间人攻击）、具有保密和认证的密钥分配（D-H协商、秘密分割、Shamir门限方案）</p><h1 id="密码协议"><a href="#密码协议" class="headerlink" title="密码协议"></a>密码协议</h1><p>数字承诺：Padersen数字承诺协议（也是基于离散对数问题）</p><p>不经意传输协议：A的秘密以0.5的概率传给B、协议执行完成后，B知道自己是否收到秘密，但A不知道B是否收到。</p><p>交互证明系统：零知识证明协议</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>加速主义政治宣言</title>
      <link href="/2023/03/02/AccManifesto/"/>
      <url>/2023/03/02/AccManifesto/</url>
      
        <content type="html"><![CDATA[<p>作者：Alex Williams &amp; Nick Srnicek</p><p><a href="http://www.cs.gettysburg.edu/~duncjo01/assets/writings/library/accelerate_manifesto.html">原文链接</a></p><p><strong>加速主义推动着一个更为现代的未来，一个新自由主义本质上无法创造的另类现代性。</strong></p><h1 id="01-引言：论时局"><a href="#01-引言：论时局" class="headerlink" title="01 引言：论时局"></a>01 引言：论时局</h1><ol><li><p>21世纪第二个十年初，全球文明面临一种新型的灾难。这些即将到来的末日事件嘲笑着在国家诞生、资本主义崛起和前所未有的战争构成的政治规范和组织结构。</p></li><li><p>最重要的是全球气候系统的破坏。随着时间的推移，这将威胁到现有全球人口的继续存在。虽然这是面临人类的最关键威胁，但还有一系列次要但同样具有潜在破坏性的问题与之并存并交错。终极资源枯竭，尤其是水和能源储备，带来了大规模饥荒、崩溃的经济范式以及新的热战和冷战前景。持续的金融危机迫使政府采取瘫痪的死亡螺旋政策，包括紧缩、社会福利服务的私有化、大规模失业和工资停滞。生产过程中“智力劳动力”的自动化不断增加，是资本主义的世俗危机的证据，很快将使其甚至无法维持北半球旧中产阶级的当前生活水平。</p></li><li><p>相比于这些不断加速的灾难，当今的政治面临着一个无力创造新思想和组织方式的难题，而这些新思想和组织方式才是必要的，才能转型我们的社会，迎接和解决即将到来的毁灭。危机在迅速积聚，而政治却在衰退和退缩。在政治想象力的瘫痪中，未来被取消了。</p></li><li><p>自1979年以来，主导全球政治的意识形态是新自由主义，虽然在领先的经济大国中有一些变体。尽管新的全球性问题给新自由主义带来了深层次的挑战，特别是2007-2008年以来的信贷、金融和财政危机，但新自由主义计划仅在加深方面发展了。这个新自由主义计划的延续，或者说新自由主义2.0，已经开始在鼓励私营部门对社会民主机构和服务的剩余部分进行新的侵略性进攻方面施加另一轮结构性调整。这是尽管这些政策立即产生了负面的经济和社会影响，而新的全球性危机带来的长期根本障碍也非常明显。</p></li><li><p> 右翼政府、非政府组织和企业力量能够推进新自由主义至少部分原因在于，许多剩余的左翼力量仍然处于瘫痪和无效状态。三十年的新自由主义使得大多数左翼政党失去了激进思想，空心化，并且缺乏普遍的授权。他们最多只是呼吁回归凯恩斯主义经济体系来应对当下的危机，尽管这种体系发生的条件已经不存在了。我们无法通过法令回到大规模工业化-福特主义劳动时代，如果有的话。即使是南美洲的波利瓦尔革命的新社会主义政权，虽然在抵抗当代资本主义的教条方面具有振奋人心的能力，但令人失望的是，他们无法超越20世纪中叶社会主义的范畴。受新自由主义项目所带来的变化而逐渐削弱的有组织劳动在制度层面上已经硬化，最多只能在缓解新的结构性调整方面稍微起到作用。但是，由于缺乏建立新经济的系统方法或实现此类变革所需的结构性团结，有组织劳动目前仍然相对无能。自冷战结束以来出现的新社会运动在2008年之后经历了一次复兴，但同样无法设计出新的政治意识形态愿景。相反，他们将大量精力用于内部直接民主进程和情感自我赞美，而不是战略上的成效，并经常主张一种新原始主义的本土主义，好像要用群体的直接性来对抗全球资本的抽象暴力。</p></li><li><p>在没有一个根本性的新的社会、政治、组织和经济愿景的情况下，右派的霸权力量将继续在任何证据面前推进其狭隘的想象。充其量，左派可能暂时能够部分抵制一些最糟糕的侵犯。但这相当于像克努特王一样站在一股最终不可抗拒的潮流前面。要生成一个新的左翼全球霸权，就需要恢复失去的可能的未来，甚至是恢复未来本身。</p></li></ol><h1 id="02-权力空位期（INTEREGNUM）：关于加速主义"><a href="#02-权力空位期（INTEREGNUM）：关于加速主义" class="headerlink" title="02 权力空位期（INTEREGNUM）：关于加速主义"></a>02 权力空位期（INTEREGNUM）：关于加速主义</h1><ol><li><p>如果要说哪个体系与加速主义的思想联系最紧密，那一定是资本主义。资本主义的基本代谢过程要求经济增长，而个体资本主义实体之间的竞争则推动着日益增长的技术发展，以期取得竞争优势，同时也伴随着日益增多的社会疏离。在其新自由主义形式中，其意识形态的自我呈现是解放创造性毁灭的力量，释放出日益加速的技术和社会创新。</p></li><li><p>哲学家尼克兰德以一种狭隘但令人着迷的信仰捕捉了这一点，即资本主义的速度本身可以生成全球范围内前所未有的技术奇点。在这种资本主义的构想中，人类最终可以被抛弃，成为抽象的行星智能体系的负担，而这一体系正在迅速构建自身，以前文明的拼凑碎片为材料。然而，兰德的新自由主义混淆了速度和加速度。我们可能移动得很快，但仅限于一个严格定义的资本主义参数集内，这些参数本身从未动摇。我们只经历了本地视野不断增长的速度，只是简单的脑死亡冲刺，而不是一种也具有导航性质的加速度，即在可能性的普遍空间内进行发现的实验性过程。后者的加速度模式是我们认为至关重要的。</p></li><li><p>更糟糕的是，正如德勒兹和瓜塔里所认识到的那样，资本主义的速度从一开始就在用一只手解除领土约束（deterritorializes），而用另一只手重新约束（reterritorializes）。进步被限制在剩余价值、劳动力储备和自由流动的资本框架内。现代性被简化为经济增长的统计度量，社会创新被困于我们共同过去的陈词滥调。撒切尔和里根式的去规范化和维多利亚时期“回归基本家庭和宗教价值观”的理念并存。</p></li><li><p>在新自由主义内部存在着更深层次的紧张关系，它在自我形象上扮演着现代性的载体，被视为现代化的同义词，同时承诺提供一种其本质上无法实现的未来。实际上，随着新自由主义的发展，它不是在促进个人创造力，而是趋向于消除认知创新，转而推崇一个脚本化交互的情感生产线，与全球供应链和新福特主义的东方生产区相结合。一个微小的精英知识工人群体正在逐年缩小，特别是在算法自动化在情感和知识劳动领域传播的同时，这种趋势变得越来越明显。虽然新自由主义把自己定位为必要的历史发展，但事实上，它只是一种应对上世纪70年代出现的价值危机的偶然手段。不可避免地，这种方式只是对危机的曲折处理，而不是对它的最终克服。</p></li><li><p>马克思和兰德都是典型的加速主义思想家，尽管有人批评，甚至一些当代马克思主义者的行为与之相悖，我们必须记住马克思本人使用了当时最先进的理论工具和实证数据来试图充分理解和改变他所处的世界。他不是一个抵制现代性的思想家，而是一个试图分析和干预现代性的思想家，他认识到尽管资本主义存在剥削和腐败，但它仍然是迄今为止最先进的经济体制。其获得的成果不应该被逆转，而应该被加速超越资本主义价值形式的限制。</p></li><li><p>实际上，甚至列宁都在1918年的《“左翼”幼稚病》一文中写到：</p><blockquote><p>社会主义离不开基于现代科学最新发现的大规模资本主义工程。离不开有计划的国家组织，让数千万人遵守统一的生产和分配标准。我们马克思主义者一直这样说，不值得花两秒钟时间与不理解这一点（如无政府主义者和左翼社会革命党人的好几位）的人谈话。</p></blockquote></li><li><p>正如马克思所意识到的，资本主义不能被视为真正加速的推手。同样，将左派政治视为与技术社会加速相对立的评价，也至少在一定程度上是一种严重的误解。实际上，如果政治左派要有未来，它必须最大程度地拥抱这种被压制的加速主义倾向。</p></li></ol><h1 id="03-宣言：未来"><a href="#03-宣言：未来" class="headerlink" title="03 宣言：未来"></a>03 宣言：未来</h1><ol><li><p>我们认为当今左派中最重要的分裂是在那些坚持民间政治、本土主义、直接行动和毫不妥协的横向主义（horizontalism）者，和那些阐述了被称为加速主义政治的人之间。前者满足于建立小而临时的非资本主义社会关系空间，回避面对本质上是非本地化、抽象化的对手和深植于我们日常基础设施中的实际问题。这种政治的失败从一开始就注定了。相比之下，加速主义政治旨在保留晚期资本主义的成果，同时超越其价值体系、治理结构和大众病态所允许的范围。</p></li><li><p>我们都想减少工作时间。令人感兴趣的问题是，为什么战后时期世界领先的经济学家认为开明的资本主义不可避免地朝着彻底减少工作时间的方向发展。凯恩斯在《我们子孙的经济前景（In The Economic Prospects for Our Grandchildren）》（写于1930年）中预测了一个资本主义的未来，个人的工作时间将被缩减到每天三小时。然而，实际发生的是工作与生活的界限被逐渐消除，工作渗透到新兴社会工厂的方方面面。</p></li><li><p>资本主义已经开始限制技术生产力，或者至少将其导向毫无必要的狭隘目标。专利战争和思想垄断是当代现象，它们指向了资本需要超越竞争的需求，以及资本日益倒退的技术方法。新自由主义的加速主义收益并没有减少工作量或减轻压力。我们所存在的时代不是一个充满太空旅行、未来冲击和革命技术潜力的世界，而是一个只有略微更好的消费小玩意儿不断出现的时代。对同一基本产品的无休止迭代，以维持微弱的消费需求，牺牲了人类的加速。</p></li><li><p>我们不想回到福特主义。福特主义已经不可能回归。资本主义的“黄金时代”建立在有序的工厂环境生产范式的基础上，（男性）工人得到安全保障和基本生活标准，作为交换，他们要忍受终身枯燥乏味和社会压抑。这种系统依赖于殖民地和帝国、欠发达地区的国际等级制度；种族主义和性别歧视的国家等级制度；以及女性受压迫的严格家庭等级制度。尽管许多人可能会怀念这种制度，但它既不可取，也在实践上不可能回到过去。</p></li><li><p>加速主义者想要释放潜在的生产力。在这个项目中，新自由主义的物质平台不需要被摧毁。它需要被重新用于共同的目标。现有的基础设施不是要被粉碎的资本主义舞台，而是一个向后资本主义发展的跳板。</p></li><li><p>鉴于技术科学自1970年代末以来被奴役于资本主义目标（尤其是自1980年代以来），我们当然不知道现代技术社会体能做些什么。我们中间谁能完全认识到已经开发出来的技术中等待被挖掘的潜力？我们打赌，很多技术和科学研究的真正转型潜力仍未被开发，其中充满了目前多余的功能（或预先适应性），在跨越短视的资本主义社会之后，这些功能可以变得决定性。</p></li><li><p>我们希望加速技术进化的过程。但我们所主张的不是技术乌托邦主义。永远不要相信技术足以拯救我们。技术是必要的，但如果没有社会政治行动，它永远不足够。技术和社会是紧密相连的，两者的变化相互作用和加强。而技术乌托邦主义者则主张通过加速技术进程来自动地克服社会冲突，而我们的立场是，应该加速技术进化，因为技术在赢得社会冲突方面是必需的。</p></li><li><p>我们认为任何后资本主义都需要后资本主义规划。如果将信仰寄托在这样一个想法上——即在革命后，人民会自发地构建一个不仅仅是回归到资本主义的新的社会经济体系——这种想法在最好的情况下是天真的，最坏的情况下是无知的。为了进一步实现这一目标，我们必须同时开发出现有系统的认知图和未来经济体系的推测形象。</p></li><li><p>因此，左翼必须利用资本主义社会所可能提供的每一个技术和科学进步。我们宣称，量化并不是要被消除的邪恶，而是应该被以最有效的方式使用的工具。经济建模是为了让复杂的世界变得清晰明了的必要手段。2008年的金融危机揭示了盲目接受数学模型的风险，然而这是权威非法的问题，而不是数学本身的问题。社会网络分析、基于代理的建模、大数据分析以及非平衡经济模型等工具，是理解现代经济这样的复杂系统所必须的认知媒介。加速主义左翼必须掌握这些技术领域的知识。</p></li><li><p>任何社会的转型都必须涉及经济和社会实验。智利的Cybersyn项目就象征了这种实验性态度——它将先进的控制论技术与复杂的经济模型融合，以及在技术基础设施中实现的民主平台。在20世纪50年代和60年代，苏联的经济学家也进行了类似的实验，他们采用了控制论和线性规划等技术，试图克服第一个共产主义经济所面临的新问题。然而，由于这些早期的控制论者所面临的政治和技术限制，导致这些实验最终都没有成功。</p></li><li><p>左派必须发展社会技术霸权：在思想领域和物质平台领域都如此。平台是全球社会的基础设施。它们建立了行为和意识形态的基本参数。在这个意义上，它们体现了社会的物质性超验：它们是特定行为、关系和权力的基础。尽管当前的全球平台在很大程度上偏向于资本主义社会关系，但这并非不可避免的必要性。这些生产、金融、物流和消费的物质平台可以而且将会被重新编程和重新格式化，以达到后资本主义的目的。</p></li><li><p>我们不认为直接行动足以实现这一切。示威、举牌和建立临时自治区的惯常策略可能会变成令人安心的替代品，而非有效的成功之路。 “至少我们做了一些事情”是那些注重自尊而非有效行动的人的呼声。唯一的良好策略标准是它是否能带来重大成功。我们必须摒弃迷信特定的行动模式。政治必须被视为一组动态系统，充满了冲突、适应和反适应以及战略军备竞赛。这意味着每种个别的政治行动模式随着对立方适应，逐渐变得迟钝和无效。没有任何一种特定的政治行动模式在历史上是不可侵犯的。事实上，随着对立方学会有效地防御和反击，丢弃熟悉策略的需要越来越大。这在一定程度上是当代左派无法做到的，这是当代病态的核心所在。</p></li><li><p>当今“激进”左派普遍将民主过程作为最为重要的事情，这种做法需要被抛弃。对于开放、水平、包容的过度追求，会导致政治行动失去效力。在实现有效的政治行动中，保密、垂直和排斥等做法同样具有必要性（当然，并非唯一必要的做法）。</p></li><li><p>民主不能简单地通过投票、讨论或大会来定义。真正的民主必须通过集体的自我掌控来定义。这是一个将政治与启蒙思想遗产对齐的项目。仅有通过调动我们更好地了解自己和我们的世界（社会、技术、经济、心理世界）的能力，我们才能自我治理。为了避免成为极权中央集权或超出我们控制的多变的新秩序的奴隶，我们需要同时实现一个集体控制的合法垂直权威和分布式的水平社交形式。规划的命令必须与网络的自发秩序相结合。</p></li><li><p>我们不认为任何特定的组织是体现这些向量的理想手段。需要的是一个组织生态系统，一个力量的多元化，不断地共鸣和反馈它们各自的优势。教条主义和集权主义同样是左派的丧钟，因此我们继续欢迎不同战术的尝试（即使是我们不同意的那些）。</p></li><li><p>我们有三个中期具体目标。首先，我们需要建立一个知识基础设施。这类似于新自由主义革命中的蒙特佩勒林协会（Mont Pelerin Society），其任务是创造一种新的意识形态、新的经济和社会模式，以及一个超越我们今天所统治的贫瘠理想的愿景。这是一种基础设施，需要建立不仅是思想，而且需要建立机构和物质途径来灌输、体现和传播它们。</p></li><li><p>我们需要建立广泛的媒介改革。尽管互联网和社交媒体似乎提供了民主化的可能性，但传统媒体机构仍然在选择和框定叙述方面至关重要，同时具有展开调查性新闻报道的资金。让这些机构尽可能地接近大众控制对于推翻当前的事态呈现至关重要。</p></li><li><p>最后，我们需要重建各种形式的阶级力量。这样的重建必须超越一个有机产生的全球无产阶级的观念。相反，它必须试图将各种零散的部分无产阶级身份联系起来，这些身份通常体现在后福特时代的不稳定劳动形式中。</p></li><li><p>已经有团体和个人在各自努力实现这些目标，但每个目标单独都不足够。需要的是三者相互反馈，每个目标在当代情境中进行修正，使其他目标变得更加有效。这是一种基础设施、意识形态、社会和经济转型的正反馈循环，产生一个新的复杂霸权，一个新的后资本主义技术社会平台。历史表明，总是广泛的战术和组织带来了系统性的变革，这些经验必须被学习。</p></li><li><p>要实现这些目标，从最实际的层面上讲，加速主义左派必须更加认真地思考建立一个有效的新政治基础设施所需的资源和资金流动。除了街头的“人民力量”外，我们需要资金支持，无论是来自政府、机构、智库、工会还是个人捐助者。我们认为定位和引导这种资金流动对于开始重建有效加速主义左翼组织的生态系统至关重要。</p></li><li><p>我们宣布，只有最大限度地掌握社会和其环境的普罗米修斯式政治才能处理全球问题或战胜资本。这种掌握必须区别于启蒙思想家钟摆式的掌控。拉普拉斯的机械宇宙——只要有足够的信息就很容易掌控——已经从严肃科学理解的议程中消失了。但这并不意味着我们要与后现代主义的疲惫残余对立，谴责掌控是一种原法西斯主义（proto-fascistic）或权威为本质上非法。相反，我们提议，困扰我们星球和物种的问题迫使我们以一种新的复杂方式重新装饰掌控；虽然我们无法预测我们行动的具体结果，但我们可以确定概率范围内的可能结果。必须与这种复杂系统分析相结合的是一种新形式的行动：即通过行动中发现的偶然性来执行设计的即兴性实践，在地理社会艺术和机智的理性政治中工作。这是一种寻求在复杂世界中行动的最佳方式的推导性实验形式。</p></li><li><p>我们需要重拾传统上为后资本主义辩护的观点：资本主义不仅是一种不公正和扭曲的制度，而且也是一种阻碍进步的制度。我们的技术发展正在受到资本主义的压制，尽管它也已经被释放出来。加速主义的基本信念是，通过超越资本主义社会所施加的限制，这些能力可以和应该被释放出来。超越我们当前限制的运动必须包括更多的内容，不仅仅是争取更加合理的全球社会的斗争。我们认为，它还必须包括恢复自19世纪中叶直到新自由主义黎明期间迷住许多人的梦想，即智人超越地球和我们的直接身体形式的追求。这些愿景今天被视为纯真时代的遗物。然而，它们既诊断了我们当今时代惊人的想象力匮乏，又提供了对一个情感上激励人心、思想上充满活力的未来的承诺。毕竟，只有后资本主义社会，由加速主义政治可能实现的社会，才能够履行20世纪中期的太空计划的兑现承诺，超越微小的技术升级，实现全面性的变革。走向集体自我掌控的时代，以及可能实现这一点的真正外来（alien）未来。走向启蒙项目的自我批判和自我掌控的完成，而不是消失。</p></li><li><p>我们面临的选择非常严峻：要么是全球化的后资本主义，要么是向原始主义、永无止境的危机和地球生态崩溃的缓慢分裂。</p></li><li><p>未来需要被建构。它已经被新自由主义资本主义摧毁，并被削减为更大的不平等、冲突和混乱的廉价承诺。这种未来观的崩溃是我们这个时代历史退步的症状，而不是像政治光谱上的愤世嫉俗者所说的那样，是怀疑主义成熟的标志。加速主义所推动的是更加现代的未来——一种新自由主义无法生成的替代现代性。未来必须再次被打开，将我们的视野解放到外在世界（the Outside）的普遍可能性。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>An unexpected post after long dissapearance</title>
      <link href="/2022/10/31/ok/"/>
      <url>/2022/10/31/ok/</url>
      
        <content type="html"><![CDATA[<p>I was just doing time in school, no thing too major. While I was at it, I fixed of a bunch of bugs… I tried to deploy remotely with ‘hexo d’, but got hit with a ‘Spawn Error’. I tried deleting ‘.deploy_git’ and rolling back like they suggested online, but proved ineffective. Turned out the config file in the root directory was the issue. The ‘Deploy’ repo was using ‘https’ method, but after switching to ‘SSH’, everything worked fine.</p><p>But then my custom domain stopped working… Checked the GitHub repo and saw that the ‘CNAME’ file had vanished. Domain control panel looked normal though. Added a custom domain in the repo settings, and voila. (Turns out I had added an ‘A record’ earlier - go figure how GitHub missed it.)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《解放的悖论——世俗革命与宗教反革命》笔记</title>
      <link href="/2022/02/16/PofLnotes/"/>
      <url>/2022/02/16/PofLnotes/</url>
      
        <content type="html"><![CDATA[<h1 id="民族解放的悖论"><a href="#民族解放的悖论" class="headerlink" title="民族解放的悖论"></a>民族解放的悖论</h1><blockquote><p>为何革命是左翼的革命，共和却是原教旨的？<br>必须彻底摈弃过去，但有很多人珍视自己的生活方式。</p></blockquote><ul><li>民族解放的两个任务：</li></ul><ol><li>从外部压迫中得到解放；</li><li>从外部压迫的内部影响——自我压迫中解放。</li></ol><ul><li><p>宗教为什么不是解放的力量？<br>解放创造“新人”，宗教宣扬的是一种服从主流社会秩序、安于现状的哲学。<br>大多数宗教制定了一种现世可行的修行制度，要求信徒服从并给予领袖权威，而这些宗教领袖往往接受殖民者的任命。<br>民族解放需要与现存的国家斗争，千年盛世的思想看似在反抗殖民者统治，长远来看却是一种政治适应——因为它无法形成稳定持久的意识形态与反抗力量。<br>获得政治独立后，传统宗教会开始构建一种反革命的政治。</p></li><li><p>解放者<br>解放者往往在压迫者的家乡和文化中接受教育。阿尔及利亚民族解放阵线中讲法语/热爱法国文化者并不少见，尼赫鲁在英国学校接受了八年教育，印度共产党的几位领导人都在英国接受教育。<br>解放者往往认同宗主国中反对派的意识形态。<br>现代意识形态、平等地位、与权威决裂。</p></li><li><p>解放<br>人民对统治者的文化和政治同情更少。<br>当解放者更可能胜出时，传统的政治宗教领袖往往被边缘化。“传统主义似乎被击败了。”<br>例外是甘地，现代主义者把印度解放后异常强大的宗教民族主义归于甘地。如今的左翼分子对甘地也采取批判态度。</p></li><li><p>那么解放后政治化的宗教是怎么产生的？<br>解放者的执政党逐渐疲软——腐败和宗教复兴看起来是同时发生的。<br>解放后宗教的影响依旧很大，民族主义领袖会发现宗教对统治的帮助很大，新统治者不敢像布尔什维克那样攻击宗教，相信“衰落是宗教的命运”。<br>旧的方式在宗教场所延续——更重要的是，在人际关系、家庭、生老病死中延续。<br>新兴精英被迫采取/主动拥抱极权政治和父权统治，民众对精英的反感推动了宗教复兴。</p></li></ul><p>结果是，落后回归了，讽刺地，它的回归主要借助于解放中建立的民主制度。</p><h1 id="否定悖论"><a href="#否定悖论" class="headerlink" title="否定悖论"></a>否定悖论</h1><p>本书的悖论与解放者与人民的紧张关系有关——同情与敌意。</p><h3 id="马克思主义的解释"><a href="#马克思主义的解释" class="headerlink" title="马克思主义的解释"></a>马克思主义的解释</h3><p>宗教信仰以及信仰造就的身份认同都是伪意识，并未接触到阶级斗争中的真实世界。解放者的民族主义未能战胜宗教，是因为民族主义也是一种源自同样原始思想和情感的伪意识。无论民族主义与宗教复兴之间的争端有多激烈，它们实际上是相互扶持的，共同促进一种狭隘的政治。实际上，殖民化是非民族的，如果解放者以为自己是在为民族解放作斗争，那就大错特错了。</p><p>作者认为，马克思主义者“动员劳动阶层革命力量”的想法造成了解放者被边缘化的政治力量，先锋队实际上是在与人民为敌——因为先锋队不可能认同宗教感情。马克思主义者诉诸普世价值，在受压迫者中培养出一种新的跨越民族的团结——国际革命——但它从未成功：无产阶级国际主义在哪里都没有取代民族认同，对异族的反抗跨越了阶级。对民族解放的批判也是一种道德批判。</p><h3 id="后殖民主义的解释"><a href="#后殖民主义的解释" class="headerlink" title="后殖民主义的解释"></a>后殖民主义的解释</h3><p>民族主义与宗教复兴都是现代性的产物，带着浪漫主义的怀旧色彩。解放者并没有挑战殖民统治产生的单一又狂热的宗教统治，而是争着运用这种惩戒性权力。</p><h3 id="宗教狂热"><a href="#宗教狂热" class="headerlink" title="宗教狂热"></a>宗教狂热</h3><p>每一个随解放运动出现的民族/宗教群体都是这个运动的试金石，如巴勒斯坦人之于以色列人。少数群体对解放运动的效仿证明了解放运动的力量——解放是一个反复发生的过程。解放主义并不是宗教狂热的源泉。宗教狂热产生于宗教信徒不想互相包容时——他们试图建立一个完全为自己的国家，而不是古典式的杂居国家。</p><h1 id="民族解放的未来"><a href="#民族解放的未来" class="headerlink" title="民族解放的未来"></a>民族解放的未来</h1><h3 id="世俗民主左派的文化重建哪里出问题了？"><a href="#世俗民主左派的文化重建哪里出问题了？" class="headerlink" title="世俗民主左派的文化重建哪里出问题了？"></a>世俗民主左派的文化重建哪里出问题了？</h3><p>出发点：解放和主导权不能靠协商取得。<br>猛烈的对抗意识不是一种创造性的力量，不会走向均衡状态。<br>作者认为，解放需要某种宗教改革——许多东西需要被否定，但它也需要一些改革解放的工作：如果一开始与传统全面接触，传统派的反革命就可以被避免，提高民族解放实现的几率，尽管如此解放的过程依旧是世俗的——解放是世间的、时长无限的、结果不由信仰——宗教或者意识形态决定——不同的接触方式，结果也是不同的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP及其安全性</title>
      <link href="/2022/02/01/HTTP_notes/"/>
      <url>/2022/02/01/HTTP_notes/</url>
      
        <content type="html"><![CDATA[<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h1 id="1-TCP-IP协议族"><a href="#1-TCP-IP协议族" class="headerlink" title="1. TCP/IP协议族"></a>1. TCP/IP协议族</h1><p>  <em>以后可能会写TCP/IP的笔记，大概…</em><br>  通常使用的网络是在TCP/IP协议族的基础上运行的，HTTP属于其子集。</p><h4 id="1-1-TCP-IP分层管理"><a href="#1-1-TCP-IP分层管理" class="headerlink" title="1.1 TCP/IP分层管理"></a>1.1 TCP/IP分层管理</h4><h3 id="分层的优势"><a href="#分层的优势" class="headerlink" title="分层的优势"></a>分层的优势</h3><p>  各层次接口调整好后，每个层次内部可以自由改动。</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><ol><li>应用层<br>应用层决定向用户提供应用服务时通信的活动。<strong>HTTP属于该层。</strong></li><li>传输层<br>传输层提供<strong>处于网络连接中的</strong>两台计算机的<strong>数据传输</strong>，有两个性质不同的协议：TCP（Transmission control protocol）与UDP（User data protocol）。</li><li>网络层<br>网络层规定了到达用户计算机并传输数据的传输路线。</li><li>链路层<br>即硬件部分。</li></ol><h4 id="1-2-TCP-IP数据传输流"><a href="#1-2-TCP-IP数据传输流" class="headerlink" title="1.2 TCP/IP数据传输流"></a>1.2 TCP/IP数据传输流</h4><p>  客户端&lt;-&gt;层&lt;-&gt;服务器<br>  发送端传输数据时，每经过一层必定被打上一个该层所属的首部信息，反之，接收端接收数据时，每经过一层必定会把对应的首部消去。这种方法称为<strong>封装</strong>。</p><h4 id="1-3-与HTTP关系密切的协议：IP-TCP与DNS"><a href="#1-3-与HTTP关系密切的协议：IP-TCP与DNS" class="headerlink" title="1.3 与HTTP关系密切的协议：IP, TCP与DNS"></a>1.3 与HTTP关系密切的协议：IP, TCP与DNS</h4><h3 id="IP（Internet-protoc）"><a href="#IP（Internet-protoc）" class="headerlink" title="IP（Internet protoc）"></a>IP（Internet protoc）</h3><p>IP协议的作用是传送数据包，确保传送两个最重要的条件是IP地址和MAC地址（Media access control address）：</p><ul><li>IP地址指明节点被分配的地址，可以变换。</li><li>MAC地址是网卡所属的固定地址，一般不会更改。</li></ul><p>IP间通信时，利用下一站中转设备的MAC地址搜索下一个中转目标，通过ARP协议（Address resolution protocol），根据对方IP地址反查MAC地址。<br>网络设备在到达中转目标的过程中，只能很粗略地获悉传输路线。这种机制称为路由选择（Routing）。换言之，<strong>不可能掌握互联网中的细节。</strong></p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP协议的作用是提供可靠的字节流服务。</p><blockquote><p>字节流服务（Byte stream protocol）：将大块数据分成以报文段（Segment）为单位的数据包进行管理，TCP协议可以确定数据是否到达。</p></blockquote><p>三次握手（three-way handshaking）策略：使用带TCP的标志（flag）————SYN（synchronize）与ACK（acknowledgement）进行传输————发送端发送带SYN的数据包，接收端收到后回传带有SYN/ACK标志的数据包，最后发送端回传带ACK标志的数据包。  </p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS服务提供从域名到IP的解析服务：通过域名查找IP地址，或从IP地址反查域名。</p><h1 id="2-URI与URL"><a href="#2-URI与URL" class="headerlink" title="2. URI与URL"></a>2. URI与URL</h1><p><em>（属于TCP/IP族，但还是分开了…）</em></p><h4 id="URI（Uniform-resource-identifier）"><a href="#URI（Uniform-resource-identifier）" class="headerlink" title="URI（Uniform resource identifier）"></a>URI（Uniform resource identifier）</h4><p>URI用字符串标识某一互联网资源。</p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>表示资源的地点，是URI的子集。</p><h4 id="URI的格式"><a href="#URI的格式" class="headerlink" title="URI的格式"></a>URI的格式</h4><ul><li>绝对URI：涵盖全部必要信息</li><li>绝对URL</li><li>相对URL</li></ul><hr><h1 id="HTTP基础"><a href="#HTTP基础" class="headerlink" title="HTTP基础"></a>HTTP基础</h1><p>HTTP用于客户端和服务器之间的通信，HTTP协议能够明确区分客户端与服务器。</p><h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p>HTTP协议规定，请求从客户端发出，服务器响应请求————通信从客户端开始建立。</p><h2 id="HTTP是一种无状态（stateless）协议，不对请求和响应之间的通信状态进行保存"><a href="#HTTP是一种无状态（stateless）协议，不对请求和响应之间的通信状态进行保存" class="headerlink" title="HTTP是一种无状态（stateless）协议，不对请求和响应之间的通信状态进行保存"></a>HTTP是一种无状态（stateless）协议，不对请求和响应之间的通信状态进行保存</h2><p>如需保存状态，需要cookie技术。</p><blockquote><h2 id="Cookie状态管理"><a href="#Cookie状态管理" class="headerlink" title="Cookie状态管理"></a>Cookie状态管理</h2><p>Cookie技术通过在请求/响应报文中写入Cookie信息控制客户端状态。<br>过程：Cookie根据服务器发送的响应报文内的Set-Cookie首部字段信息通知客户端保存Cookie，<strong>下次</strong>客户端再次发送请求时会自动加入Cookie信息。服务端收到客户端发来的Cookie后，会检查是哪个客户端的记录，接着对比服务器记录，得到之前的状态信息。</p></blockquote><h2 id="HTTP1-1新特性"><a href="#HTTP1-1新特性" class="headerlink" title="HTTP1.1新特性"></a>HTTP1.1新特性</h2><h3 id="恒久连接（Persistent-connections）"><a href="#恒久连接（Persistent-connections）" class="headerlink" title="恒久连接（Persistent connections）"></a>恒久连接（Persistent connections）</h3><p>HTTP1.1中所有连接默认为恒久连接，即任意一方未提出断开连接时保持TCP的连接状态。<br>这样做减少了服务器开销。</p><h3 id="管线化（pipelining）"><a href="#管线化（pipelining）" class="headerlink" title="管线化（pipelining）"></a>管线化（pipelining）</h3><p>同时并行发送多个请求，不必等待响应。</p><hr><h1 id="HTTP报文内的信息"><a href="#HTTP报文内的信息" class="headerlink" title="HTTP报文内的信息"></a>HTTP报文内的信息</h1><p>报文是HTTP通信基本单位，由8位组字节流组成。</p><h2 id="HTTP报文的结构"><a href="#HTTP报文的结构" class="headerlink" title="HTTP报文的结构"></a>HTTP报文的结构</h2><ol><li>报文首部（请求/状态行，请求/响应首部字段，通用首部字段，实体首部字段）</li><li>空行；</li><li>主体。</li></ol><p><strong>实体</strong>由实体首部和主体组成，作为请求和响应的补充项。 </p><h2 id="提升传输效率"><a href="#提升传输效率" class="headerlink" title="提升传输效率"></a>提升传输效率</h2><ul><li>内容编码压缩传输；</li><li>分块传输编码；</li><li>范围请求。</li></ul><h1 id="HTTP的安全漏洞"><a href="#HTTP的安全漏洞" class="headerlink" title="HTTP的安全漏洞"></a>HTTP的安全漏洞</h1><ol><li>窃听；</li><li>伪装；</li><li>篡改。<br>（安全经典三漏洞…）</li></ol><h1 id="HTTP-Secure"><a href="#HTTP-Secure" class="headerlink" title="HTTP Secure"></a>HTTP Secure</h1><p>HTTPS就是被SSL（secure socket layer)/TLS协议代替通信接口部分的HTTP。<br>HTTPS=HTTP+加密+认证+完整性保护。</p><h2 id="通信加密"><a href="#通信加密" class="headerlink" title="通信加密"></a>通信加密</h2><ul><li>SSL（secure socket layer)<br>是独立的协议，其他运行在应用层的协议都可以配合SSL使用。<blockquote><p><strong>公开密钥加密</strong>：在这种方法中，需要一对密钥，一个是私人密钥，另一个则是公开密钥。<br><strong>共享密钥加密</strong>：共享密钥加密是加密和解密都是用相同密钥的一种加密方式，这种算法也被称为“对称加密”<br>证书可以验证密钥正确性。</p></blockquote></li></ul><p>浏览器提示你证书不正确/已过期时发生了什么？</p><ul><li><p>浏览器提示证书不正确或已过期时，实际上发生了以下情况：</p><ol><li><p>浏览器向服务器发起HTTPS请求，服务器会返回自己的SSL证书。</p></li><li><p>浏览器会对服务器返回的SSL证书进行验证，验证证书的颁发机构、证书的有效期、证书中的主题等等，以确保证书的真实性和有效性。</p></li><li><p>如果证书验证失败，浏览器会弹出提示框，告诉用户证书不正确或已过期，并提示用户是否继续访问该网站。如果用户选择继续访问，浏览器会继续建立HTTPS连接，但会在地址栏中显示警告信息，提醒用户存在风险。</p></li></ol></li></ul><p>SSL的速度问题：</p><p>没有根本的解决方案，只能使用SSL加速器（专用服务器）改善问题。</p><ul><li>TLS（transport layer security）</li></ul><h2 id="验证身份"><a href="#验证身份" class="headerlink" title="验证身份"></a>验证身份</h2><p>使用SSL可以验明通信方，使用一种叫<strong>证书</strong>的手段。<br>证书由第三方机构颁发。</p><h2 id="验证完整性"><a href="#验证完整性" class="headerlink" title="验证完整性"></a>验证完整性</h2><p>遭到攻击者拦截并篡改内容的攻击：中间人攻击。</p><h3 id="防止篡改"><a href="#防止篡改" class="headerlink" title="防止篡改"></a>防止篡改</h3><p>使用散列值校验方法：MD5,SHA-1。<br>提供下载服务的网站也会提供PGP（完美隐私）创建的数字签名。<br>都需要用户亲自验证，浏览器无法自动检查。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CN </category>
          
          <category> InfoSec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> websec </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
