<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>An unexpected post after long dissapearance</title>
      <link href="/2022/10/31/ok/"/>
      <url>/2022/10/31/ok/</url>
      
        <content type="html"><![CDATA[<p>只是在学校机房坐牢而已。</p><p>发这篇的时候顺便de了一堆bug…</p><p>hexo d对远程进行部署时提示 Spawn Error，按网上说的删除.deploy_git再回滚的方式无用<br>后来发现是根目录下的配置文件有问题，Deploy下的repo用了https方法，更换为SSH方法后ok。</p><p>然后自订域名就失效了…<br>检查github仓库发现CNAME文件消失，检查域名控制台状态正常</p><p>在仓库的设定中添加costume domain，再次访问。ok。<br>（之前添加的居然是A记录，不知道当初github怎么check过的）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP笔记</title>
      <link href="/2022/03/02/TCP_IP/"/>
      <url>/2022/03/02/TCP_IP/</url>
      
        <content type="html"><![CDATA[<h1 id="1-计算机网络基础"><a href="#1-计算机网络基础" class="headerlink" title="1. 计算机网络基础"></a>1. 计算机网络基础</h1><h2 id="计算机网络历史"><a href="#计算机网络历史" class="headerlink" title="计算机网络历史"></a>计算机网络历史</h2><ol><li>批处理</li><li>分时系统<br>见操作系统笔记。</li><li>计算机间通信<br>计算机之间有通信线路连接，逐渐使用多台计算机分布式处理。</li><li>计算机网络产生<br>各式各样的计算机得以互相连接/窗口系统的产生。</li><li>互联网的普及</li></ol><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>协议可以理解为计算机与计算机通信之前达成的一种约定，只要遵循相同的协议就能够实现互相通信。<br>计算机从物理地连接层面到应用层面都必须遵守协议才能实现真正的通信。</p><h3 id="协议的制定"><a href="#协议的制定" class="headerlink" title="协议的制定"></a>协议的制定</h3><p>ISO对通信系统进行了标准化：OSI标准，但没有得到普及。<br><strong>TCP/IP并非国际标准，而是IETF致力于推进标准化作业的一种协议。</strong></p><h3 id="协议的分层"><a href="#协议的分层" class="headerlink" title="协议的分层"></a>协议的分层</h3><p>OSI参考模型，被分为七层。上下层之间进行交互时遵循的约定叫做接口，同一层之间交互遵循的约定叫做协议。<br>从上（用户）到下：应用层，表示层，会话层，传输层，网路层，数据链路层，物理层。<br>硬件部分详见网络硬件笔记。</p><p>考完了懒得继续写，，，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《解放的悖论——世俗革命与宗教反革命》笔记</title>
      <link href="/2022/02/16/PofLnotes/"/>
      <url>/2022/02/16/PofLnotes/</url>
      
        <content type="html"><![CDATA[<h1 id="民族解放的悖论"><a href="#民族解放的悖论" class="headerlink" title="民族解放的悖论"></a>民族解放的悖论</h1><blockquote><p>为何革命是左翼的革命，共和却是原教旨的？<br>必须彻底摈弃过去，但有很多人珍视自己的生活方式。</p></blockquote><ul><li>民族解放的两个任务：</li></ul><ol><li>从外部压迫中得到解放；</li><li>从外部压迫的内部影响——自我压迫中解放。</li></ol><ul><li><p>宗教为什么不是解放的力量？<br>解放创造“新人”，宗教宣扬的是一种服从主流社会秩序、安于现状的哲学。<br>大多数宗教制定了一种现世可行的修行制度，要求信徒服从并给予领袖权威，而这些宗教领袖往往接受殖民者的任命。<br>民族解放需要与现存的国家斗争，千年盛世的思想看似在反抗殖民者统治，长远来看却是一种政治适应——因为它无法形成稳定持久的意识形态与反抗力量。<br>获得政治独立后，传统宗教会开始构建一种反革命的政治。</p></li><li><p>解放者<br>解放者往往在压迫者的家乡和文化中接受教育。阿尔及利亚民族解放阵线中讲法语/热爱法国文化者并不少见，尼赫鲁在英国学校接受了八年教育，印度共产党的几位领导人都在英国接受教育。<br>解放者往往认同宗主国中反对派的意识形态。<br>现代意识形态、平等地位、与权威决裂。</p></li><li><p>解放<br>人民对统治者的文化和政治同情更少。<br>当解放者更可能胜出时，传统的政治宗教领袖往往被边缘化。“传统主义似乎被击败了。”<br>例外是甘地，现代主义者把印度解放后异常强大的宗教民族主义归于甘地。如今的左翼分子对甘地也采取批判态度。</p></li><li><p>那么解放后政治化的宗教是怎么产生的？<br>解放者的执政党逐渐疲软——腐败和宗教复兴看起来是同时发生的。<br>解放后宗教的影响依旧很大，民族主义领袖会发现宗教对统治的帮助很大，新统治者不敢像布尔什维克那样攻击宗教，相信“衰落是宗教的命运”。<br>旧的方式在宗教场所延续——更重要的是，在人际关系、家庭、生老病死中延续。<br>新兴精英被迫采取/主动拥抱极权政治和父权统治，民众对精英的反感推动了宗教复兴。</p></li></ul><p>结果是，落后回归了，讽刺地，它的回归主要借助于解放中建立的民主制度。</p><h1 id="否定悖论"><a href="#否定悖论" class="headerlink" title="否定悖论"></a>否定悖论</h1><p>本书的悖论与解放者与人民的紧张关系有关——同情与敌意。</p><h3 id="马克思主义的解释"><a href="#马克思主义的解释" class="headerlink" title="马克思主义的解释"></a>马克思主义的解释</h3><p>宗教信仰以及信仰造就的身份认同都是伪意识，并未接触到阶级斗争中的真实世界。解放者的民族主义未能战胜宗教，是因为民族主义也是一种源自同样原始思想和情感的伪意识。无论民族主义与宗教复兴之间的争端有多激烈，它们实际上是相互扶持的，共同促进一种狭隘的政治。实际上，殖民化是非民族的，如果解放者以为自己是在为民族解放作斗争，那就大错特错了。</p><p>作者认为，马克思主义者“动员劳动阶层革命力量”的想法造成了解放者被边缘化的政治力量，先锋队实际上是在与人民为敌——因为先锋队不可能认同宗教感情。马克思主义者诉诸普世价值，在受压迫者中培养出一种新的跨越民族的团结——国际革命——但它从未成功：无产阶级国际主义在哪里都没有取代民族认同，对异族的反抗跨越了阶级。对民族解放的批判也是一种道德批判。</p><h3 id="后殖民主义的解释"><a href="#后殖民主义的解释" class="headerlink" title="后殖民主义的解释"></a>后殖民主义的解释</h3><p>民族主义与宗教复兴都是现代性的产物，带着浪漫主义的怀旧色彩。解放者并没有挑战殖民统治产生的单一又狂热的宗教统治，而是争着运用这种惩戒性权力。</p><h3 id="宗教狂热"><a href="#宗教狂热" class="headerlink" title="宗教狂热"></a>宗教狂热</h3><p>每一个随解放运动出现的民族/宗教群体都是这个运动的试金石，如巴勒斯坦人之于以色列人。少数群体对解放运动的效仿证明了解放运动的力量——解放是一个反复发生的过程。解放主义并不是宗教狂热的源泉。宗教狂热产生于宗教信徒不想互相包容时——他们试图建立一个完全为自己的国家，而不是古典式的杂居国家。</p><h1 id="民族解放的未来"><a href="#民族解放的未来" class="headerlink" title="民族解放的未来"></a>民族解放的未来</h1><h3 id="世俗民主左派的文化重建哪里出问题了？"><a href="#世俗民主左派的文化重建哪里出问题了？" class="headerlink" title="世俗民主左派的文化重建哪里出问题了？"></a>世俗民主左派的文化重建哪里出问题了？</h3><p>出发点：解放和主导权不能靠协商取得。<br>猛烈的对抗意识不是一种创造性的力量，不会走向均衡状态。<br>作者认为，解放需要某种宗教改革——许多东西需要被否定，但它也需要一些改革解放的工作：如果一开始与传统全面接触，传统派的反革命就可以被避免，提高民族解放实现的几率，尽管如此解放的过程依旧是世俗的——解放是世间的、时长无限的、结果不由信仰——宗教或者意识形态决定——不同的接触方式，结果也是不同的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web安全概览</title>
      <link href="/2022/02/14/intro_websec/"/>
      <url>/2022/02/14/intro_websec/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Web介绍"><a href="#1-Web介绍" class="headerlink" title="1. Web介绍"></a>1. Web介绍</h1><h2 id="Web发展史"><a href="#Web发展史" class="headerlink" title="Web发展史"></a>Web发展史</h2><ol><li>web1.0时代：主要危害web服务器</li><li>web2.0时代：主要危害web用户</li></ol><h2 id="web流程（见HTTP学习笔记）"><a href="#web流程（见HTTP学习笔记）" class="headerlink" title="web流程（见HTTP学习笔记）"></a>web流程（见<a href="https://blog.ariax.icu/2022/02/01/HTTP_notes/">HTTP学习笔记</a>）</h2><p>可见的流程：用户请求访问网站，浏览器返回网页界面。（客户端/前端）<br>不可见的流程：浏览器向服务器请求资源，服务器与数据库交互，返回网页信息。（服务端/后端）<br>上述问题也可以用客户端/服务端分类</p><h2 id="浏览器工作原理（见浏览器学习笔记）"><a href="#浏览器工作原理（见浏览器学习笔记）" class="headerlink" title="浏览器工作原理（见浏览器学习笔记）"></a>浏览器工作原理（见<a href="#">浏览器学习笔记</a>）</h2><p>浏览器通过DNS解析将获取的域名解析为IP地址，通过HTTP协议进行通信。<br>开发者工具-network。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>webshell<br>Webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境。“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。</li><li>菜刀<br>连接服务器的工具。</li><li>0day<br>又称“零日漏洞”(zero-day)，是已经被发现(有可能未被公开)，而官方还没有相关补丁的漏洞。</li><li>SQL注入<br>发生在 Web 程序中数据库层的安全漏洞。主要原因是程序对用户输入数据的合法性没有判断和处理，导致攻击者可以在 Web 应用程序中事先定义好的 SQL 语句中添加额外的 SQL 语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步获取到数据信息。</li><li>文件上传漏洞<br>由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。</li><li>一句话木马<br>通过向服务端提交一句简短的代码来达到向服务器插入木马并最终获得webshell的方法。</li></ul><h1 id="2-语言基础"><a href="#2-语言基础" class="headerlink" title="2. 语言基础"></a>2. 语言基础</h1><h2 id="Web前端"><a href="#Web前端" class="headerlink" title="Web前端"></a>Web前端</h2><h3 id="见：HTML与DOM"><a href="#见：HTML与DOM" class="headerlink" title="见：HTML与DOM"></a><a href="#">见：HTML与DOM</a></h3><h3 id="见：JavaScript"><a href="#见：JavaScript" class="headerlink" title="见：JavaScript"></a><a href="#">见：JavaScript</a></h3><h2 id="Web服务端"><a href="#Web服务端" class="headerlink" title="Web服务端"></a>Web服务端</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>概述：一种结构化的查询语言，可以访问查询数据库。通过SQL语言指令操作数据库系统，数据库系统返回数据或执行结果，通过Web服务返回包装后的数据。<br>数据的增删改查、内置函数语法见学习笔记。</p><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>超文本预处理器。一种开源脚本语言，在服务器上执行。<br>语法：</p><ul><li>脚本范围：<?php ?></li><li>注释：//、#、/* */</li><li>echo语句输出多个语句。print为函数，依次输出一个语句且有返回值。</li><li>串接：.</li><li>函数：function 函数名()</li><li>变量：$变量名。区分大小写。</li><li>$_POST与$_GET</li><li>$_FILES</li><li>$_SERVER</li><li>文件的包含：include</li></ul><p>PHP如何连接并操作数据库？</p><ol><li>连接MySql服务：mysql_connect(“”);</li><li>设定编码: mysql_query(“SET NAMES UTF8”);</li><li>选定数据库: mysql_select_db(“”,$con);</li><li>操作数据库： mysql_query(“SELECT * FROM …”);</li><li>关闭连接：mysql_close($con);</li></ol><p>.# 3. 常见安全事件</p><h2 id="HTTP基础（HTTP与Web安全）"><a href="#HTTP基础（HTTP与Web安全）" class="headerlink" title="HTTP基础（HTTP与Web安全）"></a>HTTP基础（<a href="https://blog.ariax.icu/2022/02/06/HTTPSwebsec/">HTTP与Web安全</a>）</h2><p>一些会造成严重安全问题的HTTP头部信息：</p><ul><li>User-Agent<br>即用户代理，简称“UA”，它是一个特殊字符串头。网站服务器通过识别 “UA”来确定用户所使用的操作系统版本、CPU 类型、浏览器版本等信息。而网站服务器则通过判断 UA 来给客户端发送不同的页面。<br>网站通过识别请求头中 User-Agent 信息来判断是否是爬虫访问网站。如果是，网站首先对该 IP 进行预警，对其进行重点监控，当发现该 IP 超过规定时间内的访问次数， 将在一段时间内禁止其再次访问网站。</li><li>X-Forwarded-For<br>最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。HTTP 连接基于 TCP 连接，HTTP 协议中没有 IP 的概念，Remote Address 来自 TCP 连接，表示与服务端建立 TCP 连接的设备 IP。Remote Address 无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源 IP，无法建立 TCP 连接，更不会有后面的 HTTP 请求。</li><li>Referer<br>Referer 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。Referer 请求头可能暴露用户的浏览历史，涉及到用户的隐私问题。来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI或当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）时Referer不会被发送。</li><li>clien_ip<br>不懂</li><li>Cookie<br>cookie通常是服务器发放给客户端的一小段文本信息，相当于用户的钥匙。<br>document.cookie可以获取、写入cookie信息。</li></ul><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS攻击全称跨站脚本攻击，是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>通过伪装来自受信任用户的请求来利用受信任的网站发送恶意请求。</p><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><h2 id="URL跳转"><a href="#URL跳转" class="headerlink" title="URL跳转"></a>URL跳转</h2><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h2 id="命令注入解释"><a href="#命令注入解释" class="headerlink" title="命令注入解释"></a>命令注入解释</h2><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h1 id="4-代理工具"><a href="#4-代理工具" class="headerlink" title="4.代理工具"></a>4.代理工具</h1><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><h2 id="漏洞扫描工具"><a href="#漏洞扫描工具" class="headerlink" title="漏洞扫描工具"></a>漏洞扫描工具</h2><h2 id="SQL注入漏洞测试"><a href="#SQL注入漏洞测试" class="headerlink" title="SQL注入漏洞测试"></a>SQL注入漏洞测试</h2><h2 id="敏感文件探测"><a href="#敏感文件探测" class="headerlink" title="敏感文件探测"></a>敏感文件探测</h2>]]></content>
      
      
      
        <tags>
            
            <tag> websec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA基础题解</title>
      <link href="/2022/02/13/pta_base/"/>
      <url>/2022/02/13/pta_base/</url>
      
        <content type="html"><![CDATA[<h2 id="6-2-多项式求值-15-分"><a href="#6-2-多项式求值-15-分" class="headerlink" title="6-2 多项式求值 (15 分)"></a>6-2 多项式求值 (15 分)</h2><p>本题要求实现一个函数，计算阶数为n，系数为a[0] … a[n]的多项式f(x)=∑ (i=0~n)(a[i]*x^i) 在x点的值。</p><p>函数接口定义：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">f</span><span class="token punctuation">(</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">double</span> x <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中n是多项式的阶数，a[]中存储系数，x是给定点。函数须返回多项式f(x)的值。</p><p>裁判测试程序样例：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> MAXN 10</span><span class="token keyword">double</span> <span class="token function">f</span><span class="token punctuation">(</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">double</span> x <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token keyword">double</span> a<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.1f\n"</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 你的代码将被嵌在这里 */</span></code></pre><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><blockquote><p>逻辑过程为：</p><ol><li>获取每个数组元素；</li><li>通过获取的数组index计算并保存x的幂；</li><li>数组元素*x的幂；</li><li>上述相加，返回。</li></ol></blockquote><p>实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">f</span><span class="token punctuation">(</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">double</span> x <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> sum<span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>m<span class="token operator">=</span><span class="token number">1.00</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//可以同时获取index与value；</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        m<span class="token operator">*</span><span class="token operator">=</span>x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//m储存x的幂；</span>        sum<span class="token operator">+</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>m<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>sum=0;从数组最开始获取如何？<br>答：不可以。m在i=0时也会*x，造成错误。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记</title>
      <link href="/2022/02/12/gitnotes/"/>
      <url>/2022/02/12/gitnotes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考:<a href=https://www.runoob.com/git/git-basic-operations.html>菜鸟git教程</a><br>    <a href=https://edu.aliyun.com/roadmap/frontend>阿里云git教程</a></p></blockquote><h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><p><code>git init</code> 初始化git生成git仓库<br><code>git status</code> 查看git状态<br><code>git add &lt;filename&gt;</code>添文件到暂存区<br><code>git add .</code>加入所有文件到暂存区<br><code>git commit -m &#39;message&#39;</code>提交文件到本地仓库，message为变更描述。每个commit会生成一个唯一的哈希值<br><code>git reflog</code>查看日志<br><code>git reset &lt;filename&gt;</code>将尚没有commite之前加入到暂存区的文件重新拉回<br><code>git checkout &lt;newbranchname&gt; &lt;refbranch&gt;</code>以参考分支为模板创建新分支<br><code>git checkout &lt;branchname&gt;</code>切换到指定分支​</p><h1 id="文件状态："><a href="#文件状态：" class="headerlink" title="文件状态："></a>文件状态：</h1><p>工作区：就是你在电脑里能看到的目录。</p><p>暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</p><p>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><p>1.没有被add过的文件叫untracked<br>2.add之后文件处于staged状态等待commite<br>3.commit之后文件处于unmodified这里之所以是modified是因为文件会跟仓库中的文件对比<br>4.当unmodified的文件被修改则会变为modified状态<br>5.modified之后的文件add之后将继续变为staged状态<br>6.unmodifed的文件还有一种可能是已经不再需要了，那么可以remove它不再追踪变为untracked状态​</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP与web安全</title>
      <link href="/2022/02/06/HTTPSwebsec/"/>
      <url>/2022/02/06/HTTPSwebsec/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP的安全漏洞"><a href="#HTTP的安全漏洞" class="headerlink" title="HTTP的安全漏洞"></a>HTTP的安全漏洞</h1><ol><li>通信使用明文，可能会被窃听；</li><li>不验证通信方的身份，可能被伪装；</li><li>无法验证报文的完整性，有可能遭到篡改。</li></ol><h1 id="HTTP-Secure"><a href="#HTTP-Secure" class="headerlink" title="HTTP Secure"></a>HTTP Secure</h1><p>HTTPS就是被SSL（secure socket layer)/TLS协议代替通信接口部分的HTTP。<br>HTTPS=HTTP+加密+认证+完整性保护。</p><h2 id="通信加密"><a href="#通信加密" class="headerlink" title="通信加密"></a>通信加密</h2><ul><li>SSL（secure socket layer)<br>是独立的协议，其他运行在应用层的协议都可以配合SSL使用。<blockquote><p><strong>公开密钥加密</strong>：也称为非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥，一个是私人密钥，另一个则是公开密钥。 这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。<br><strong>共享密钥加密</strong>：共享密钥加密是加密和解密都是用相同密钥的一种加密方式，由于使用的密钥相同，所以这种算法也被称为“对称加密”<br>证书可以验证密钥正确性。</p></blockquote></li></ul><p>SSL的速度问题：</p><ol><li>除了HTTP通信外还需要进行SSL通信，增加了通信量；</li><li>SSL进行加密处理，更多地耗费硬件资源。</li></ol><p>没有根本的解决方案，只能使用SSL加速器（专用服务器）改善问题。</p><ul><li>TLS（transport layer security）</li></ul><h2 id="验证身份"><a href="#验证身份" class="headerlink" title="验证身份"></a>验证身份</h2><p>使用SSL可以验明通信方，使用一种叫<strong>证书</strong>的手段。<br>证书由第三方机构颁发。</p><h2 id="验证完整性"><a href="#验证完整性" class="headerlink" title="验证完整性"></a>验证完整性</h2><p>遭到攻击者拦截并篡改内容的攻击：中间人攻击。</p><h3 id="防止篡改"><a href="#防止篡改" class="headerlink" title="防止篡改"></a>防止篡改</h3><p>使用散列值校验方法：MD5,SHA-1。<br>提供下载服务的网站也会提供PGP（完美隐私）创建的数字签名。<br>都需要用户亲自验证，浏览器无法自动检查。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> websec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP学习笔记</title>
      <link href="/2022/02/01/HTTP_notes/"/>
      <url>/2022/02/01/HTTP_notes/</url>
      
        <content type="html"><![CDATA[<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h1 id="1-TCP-IP协议族"><a href="#1-TCP-IP协议族" class="headerlink" title="1. TCP/IP协议族"></a>1. TCP/IP协议族</h1><p>  <em>以后可能会写TCP/IP的笔记，大概…</em><br>  通常使用的网络是在TCP/IP协议族的基础上运行的，HTTP属于其子集。</p><p>  解释：网络设备间的互相通信必须基于相同的方法：如何探测目标、发起通信、使用语言、结束通信。这一切的规则被称为协议（protocol）。与互联网有关的协议的集合称为TCP/IP。</p><h4 id="1-1-TCP-IP分层管理"><a href="#1-1-TCP-IP分层管理" class="headerlink" title="1.1 TCP/IP分层管理"></a>1.1 TCP/IP分层管理</h4><h3 id="分层的优势"><a href="#分层的优势" class="headerlink" title="分层的优势"></a>分层的优势</h3><p>  各层次接口调整好后，每个层次内部可以自由改动。</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><ol><li>应用层<br>应用层决定向用户提供应用服务时通信的活动。<strong>HTTP属于该层。</strong></li><li>传输层<br>传输层提供<strong>处于网络连接中的</strong>两台计算机的<strong>数据传输</strong>，有两个性质不同的协议：TCP（Transmission control protocol）与UDP（User data protocol）。</li><li>网络层<br>网络层规定了到达用户计算机并传输数据的传输路线。</li><li>链路层<br>即硬件部分。</li></ol><h4 id="1-2-TCP-IP数据传输流"><a href="#1-2-TCP-IP数据传输流" class="headerlink" title="1.2 TCP/IP数据传输流"></a>1.2 TCP/IP数据传输流</h4><p>  客户端&lt;-&gt;层&lt;-&gt;服务器<br>  发送端传输数据时，每经过一层必定被打上一个该层所属的首部信息，反之，接收端接收数据时，每经过一层必定会把对应的首部消去。这种方法称为<strong>封装</strong>。</p><h4 id="1-3-与HTTP关系密切的协议：IP-TCP与DNS"><a href="#1-3-与HTTP关系密切的协议：IP-TCP与DNS" class="headerlink" title="1.3 与HTTP关系密切的协议：IP, TCP与DNS"></a>1.3 与HTTP关系密切的协议：IP, TCP与DNS</h4><h3 id="IP（Internet-protoc）"><a href="#IP（Internet-protoc）" class="headerlink" title="IP（Internet protoc）"></a>IP（Internet protoc）</h3><p>IP协议的作用是传送数据包，确保传送两个最重要的条件是IP地址和MAC地址（Media access control address）：</p><ul><li>IP地址指明节点被分配的地址，可以变换。</li><li>MAC地址是网卡所属的固定地址，一般不会更改。</li></ul><p>IP间通信时，利用下一站中转设备的MAC地址搜索下一个中转目标，通过ARP协议（Address resolution protocol），根据对方IP地址反查MAC地址。<br>网络设备在到达中转目标的过程中，只能很粗略地获悉传输路线。这种机制称为路由选择（Routing）。换言之，<strong>不可能掌握互联网中的细节。</strong></p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP协议的作用是提供可靠的字节流服务。</p><blockquote><p>字节流服务（Byte stream protocol）：为了方便传输，将大块数据分成以报文段（Segment）为单位的数据包进行管理，<br>TCP协议可以确定数据是否到达。</p></blockquote><p>三次握手（three-way handshaking）策略：使用带TCP的标志（flag）————SYN（synchronize）与ACK（acknowledgement）进行传输————发送端发送带SYN的数据包，接收端收到后回传带有SYN/ACK标志的数据包，最后发送端回传带ACK标志的数据包。  </p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS服务提供从域名到IP的解析服务：通过域名查找IP地址，或从IP地址反查域名。</p><h1 id="2-URI与URL"><a href="#2-URI与URL" class="headerlink" title="2. URI与URL"></a>2. URI与URL</h1><p><em>（属于TCP/IP族，但还是分开了…）</em></p><h4 id="URI（Uniform-resource-identifier）"><a href="#URI（Uniform-resource-identifier）" class="headerlink" title="URI（Uniform resource identifier）"></a>URI（Uniform resource identifier）</h4><p>URI用字符串标识某一互联网资源，标准的URI协议有30种左右。</p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>表示资源的地点，是URI的子集。</p><h4 id="URI的格式"><a href="#URI的格式" class="headerlink" title="URI的格式"></a>URI的格式</h4><ul><li>绝对URI：涵盖全部必要信息</li><li>绝对URL</li><li>相对URL</li></ul><hr><h1 id="HTTP基础"><a href="#HTTP基础" class="headerlink" title="HTTP基础"></a>HTTP基础</h1><p>HTTP用于客户端和服务器之间的通信，HTTP协议能够明确区分客户端与服务器。</p><h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p>HTTP协议规定，请求从客户端发出，服务器响应请求————通信从客户端开始建立。</p><h3 id="请求的组成"><a href="#请求的组成" class="headerlink" title="请求的组成"></a>请求的组成</h3><ol><li>方法（method），表示请求访问服务器的类型；</li><li>请求URI（request-URI）；</li><li>HTTP版本号；</li><li>可选的请求首部字段；</li><li>内容实体。</li></ol><h3 id="响应的组成"><a href="#响应的组成" class="headerlink" title="响应的组成"></a>响应的组成</h3><ol><li>版本号；</li><li>状态码；</li><li>原因短语；</li><li>可选的响应首部字段；</li><li>内容实体。</li></ol><h2 id="HTTP是一种无状态（stateless）协议，不对请求和响应之间的通信状态进行保存"><a href="#HTTP是一种无状态（stateless）协议，不对请求和响应之间的通信状态进行保存" class="headerlink" title="HTTP是一种无状态（stateless）协议，不对请求和响应之间的通信状态进行保存"></a>HTTP是一种无状态（stateless）协议，不对请求和响应之间的通信状态进行保存</h2><p>为了处理大量事务，确保可伸缩性（？）。如需保存状态，需要cookie技术。</p><blockquote><h2 id="Cookie状态管理"><a href="#Cookie状态管理" class="headerlink" title="Cookie状态管理"></a>Cookie状态管理</h2><p>Cookie技术通过在请求/响应报文中写入Cookie信息控制客户端状态。<br>过程：Cookie根据服务器发送的响应报文内的Set-Cookie首部字段信息通知客户端保存Cookie，<strong>下次</strong>客户端再次发送请求时会自动加入Cookie信息。服务端收到客户端发来的Cookie后，会检查是哪个客户端的记录，接着对比服务器记录，得到之前的状态信息。</p></blockquote><h2 id="HTTP1-1新特性"><a href="#HTTP1-1新特性" class="headerlink" title="HTTP1.1新特性"></a>HTTP1.1新特性</h2><h3 id="恒久连接（Persistent-connections）"><a href="#恒久连接（Persistent-connections）" class="headerlink" title="恒久连接（Persistent connections）"></a>恒久连接（Persistent connections）</h3><p>HTTP1.1中所有连接默认为恒久连接，即任意一方未提出断开连接时保持TCP的连接状态。<br>这样做减少了服务器开销。</p><h3 id="管线化（pipelining）"><a href="#管线化（pipelining）" class="headerlink" title="管线化（pipelining）"></a>管线化（pipelining）</h3><p>同时并行发送多个请求，不必等待响应。</p><hr><h1 id="HTTP报文内的信息"><a href="#HTTP报文内的信息" class="headerlink" title="HTTP报文内的信息"></a>HTTP报文内的信息</h1><p>报文是HTTP通信基本单位，由8位组字节流组成。</p><h2 id="HTTP报文的结构"><a href="#HTTP报文的结构" class="headerlink" title="HTTP报文的结构"></a>HTTP报文的结构</h2><ol><li>报文首部（请求/状态行，请求/响应首部字段，通用首部字段，实体首部字段）</li><li>空行；</li><li>主体。</li></ol><p><strong>实体</strong>由实体首部和主体组成，作为请求和响应的补充项。 </p><h2 id="常用返回状态码"><a href="#常用返回状态码" class="headerlink" title="常用返回状态码"></a>常用返回状态码</h2><ul><li>2xx成功；</li><li>3xx重定向；</li><li>4xx客户端错误；<ul><li>400 bad request：报文存在语法错误</li><li>402 unauthorized：需要通过HTTP认证</li><li>403 forbidd：请求资源被服务器拒绝</li><li>404 not found：服务器上无法找到请求资源</li></ul></li><li>5xx服务器错误<ul><li>503 service unavailable：服务器繁忙或正在维护</li></ul></li></ul><p>有时状态码与结果不一致。</p><h2 id="提升传输效率"><a href="#提升传输效率" class="headerlink" title="提升传输效率"></a>提升传输效率</h2><ul><li>内容编码压缩传输；</li><li>分块传输编码；</li><li>范围请求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CN </category>
          
          <category> InfoSec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> websec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以后会用到的小TIPS</title>
      <link href="/2022/01/30/Tips-1/"/>
      <url>/2022/01/30/Tips-1/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li>调整<code>&lt;img&gt;</code>图像大小时最好用Photoshop等工具调整————用width/height属性调整的弊端：尺寸属性不改变图像大小，只是帮助浏览器确定需要预留的空间，仍然会下载完整大小的图像.</li><li>视障人士/网络故障友好：在<code>&lt;img&gt;</code>标签内添加alt=”description”。</li><li>一个经验：图像宽度小于800像素（一般浏览器默认宽度）</li><li>反锯齿处理：柔化文本、透明图像的边缘，更有可读性。</li></ul><h1 id="工业级HTML"><a href="#工业级HTML" class="headerlink" title="工业级HTML"></a>工业级HTML</h1><h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p>HTML标准是一种“living standard”，由W3C制定，HTML5为当前标准，向后兼容。<br>可用验证工具验证HTML代码的严谨性。</p><h2 id="核对-EMMET语法"><a href="#核对-EMMET语法" class="headerlink" title="核对/EMMET语法"></a>核对/EMMET语法</h2><ul><li>Visual Code中，输入英文“!”+TAB，快速生成包括<code>doctype, &lt;html&gt;, &lt;meta&gt;, &lt;body&gt;</code>HTML结构；</li><li>同上，输入tag名+TAB，生成tag结构；以上两条可以减少疏漏。</li><li>输入tag*数字生成多个tag。</li><li>父子关系标签，如ul&gt;li。</li><li>兄弟关系标签，如div+p。</li><li>生成类名或id名的，.xxx/#xxx（以上默认div）/p.xxx等。</li><li>div类名有顺序：.xxx$数字。</li><li>想生成的内容包含在{}内。</li><li>注意嵌套规则：<ul><li>至多嵌套一层</li><li>内联元素不可嵌套</li></ul></li><li>检查tag的属性是否全面。<h2 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h2>HTML5非常适合创建博客。</li><li><code>&lt;header&gt;</code>与<code>&lt;footer&gt;</code>属性：页眉页脚。</li><li><code>&lt;aside&gt;</code>属性：侧边栏。</li><li><code>&lt;section&gt;</code>属性：一组相关内容。</li><li><code>&lt;article&gt;</code>属性：一篇博客。</li><li><code>&lt;time&gt;</code>属性：日期/时间。</li><li><code>&lt;nav&gt;</code>属性：导航。</li><li><code>&lt;video&gt;</code>属性：增加视频文件。</li></ul><hr><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><ul><li>font-family<ol><li>serif：带有衬线的字体；</li><li>sans-serif：没有衬线的字体；</li><li>cursive： 看起来像手写的字体；</li><li>monospace： 字符固定宽度的字体；</li><li>fantasy：某种风格的装饰字体。</li></ol></li></ul><p>指定的字体系列是一个候选<strong>列表</strong>，最后一个总是系列名，取代它的是电脑默认字体。</p><ul><li><p>woff（web open font format）是web字体的标准格式。有些浏览器可能不支持woff格式，需要多个格式作为候选。要使用一个web字体，需要在一个服务器上托管字体文件。</p></li><li><p>@font-face规则为用户提供字体。放在文件最上。</p><pre><code>@font-face&#123; font-family: &quot;Emblema One&quot;; src: url(&quot;http://..../emblema-one.woff&quot;); url(&quot;http://..../emblema-one.ttf&quot;);&#125;</code></pre><p>@font-face不是一个选择器规则，可以理解为一种内置规则。<br>定制多个字体时，每个字体使用一个font-family。</p></li><li><p>font-size指定方法</p><ol><li>直接使用px；</li><li>用百分数或em，指相对于父元素(body)的大小；</li><li>关键字。</li></ol></li><li><p>color规则实际上控制着字体的前景色，包括文本和边框颜色。</p></li></ul><h2 id="关于class与id"><a href="#关于class与id" class="headerlink" title="关于class与id"></a>关于class与id</h2><ul><li>对于希望成组指定样式的元素使用class，为元素指定<strong>唯一</strong>一个名字/样式时使用id。</li><li>id选择器：#xxx。</li><li>HTML中可以有多个样式器，最下方的优先级最高。</li><li>在HTML的<code>&lt;link&gt;</code>元素中可以使用媒体查询，如<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;tablet-landscape.css&quot; media=&quot;screen and (max-device-width:1024px) and (orientation: landscape)&quot;&gt;</code>,或者使用css中的@media规则，如<pre><code>@media screen and (max-device-width: 481px)&#123; #xxx&#123;    ... &#125;&#125;</code></pre></li></ul><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>border（边框），content（内容），padding（内边距），margin（外边距）</p><h3 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h3><ul><li><p>border属性<br>border-width：边框粗细；<br>border-style：边框样式；<br>border-color：边框颜色。<br><strong>border-collapse</strong>表示相邻边框合在一起。</p></li><li><p><code>border：1px solid red;</code>没有顺序。注意优先级顺序。</p></li><li><p><code>padding:上下左右;</code>,margin同。</p></li></ul><h3 id="盒子实际大小"><a href="#盒子实际大小" class="headerlink" title="盒子实际大小"></a>盒子实际大小</h3><ul><li>border会影响盒子的实际大小。<br>解决方法：<ol><li>测量盒子大小时不量边框；</li><li>如果包含边框，需要width/hight减去边框宽度。</li></ol></li></ul><p>-padding会影响盒子的实际大小。<br>解决方法同上。<br>盒子本身没有指定w/h属性，padding不会撑开盒子大小。</p><h3 id="块级盒子水平居中"><a href="#块级盒子水平居中" class="headerlink" title="块级盒子水平居中"></a>块级盒子水平居中</h3><p>必须指定宽度，左右margin设置为auto。（<code>margin:0 auto</code>）</p><h3 id="行内（块）元素水平居中"><a href="#行内（块）元素水平居中" class="headerlink" title="行内（块）元素水平居中"></a>行内（块）元素水平居中</h3><p>给父元素添加<code>text-align: center;</code></p><h3 id="父元素塌陷"><a href="#父元素塌陷" class="headerlink" title="父元素塌陷"></a>父元素塌陷</h3><p>两个嵌套元素的块元素，父元素和子元素都有上外边距时，此时父元素会塌陷较大的外边距值。<br>解决方案：</p><ol><li>为父元素定义上边框；</li><li>为父元素定义上内边框；</li><li><strong>为父元素添加：overflow：hidden。</strong></li></ol><h3 id="清除内外边距"><a href="#清除内外边距" class="headerlink" title="清除内外边距"></a>清除内外边距</h3><p>不同元素带有不同的内外边距，不同浏览器也不同。</p><pre class=" language-[lang:css]"><code class="language-[lang:css]">*&#123;   padding: 0;   margin: 0;&#125;</code></pre><p>行内元素为了兼容。尽量只设置左右边距。转换为（行内）块级元素就可以了。</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p><code>float: right/left/none</code></p><h3 id="传统网页的三种布局方式"><a href="#传统网页的三种布局方式" class="headerlink" title="传统网页的三种布局方式"></a>传统网页的三种布局方式</h3><ol><li>标准流</li><li>浮动</li><li>定位</li></ol><h3 id="为什么需要浮动"><a href="#为什么需要浮动" class="headerlink" title="为什么需要浮动"></a>为什么需要浮动</h3><p>标准流很难实现某种效果。可以改变标签默认排列方式。纵向排列用标准流，横向排列用浮动。</p><h3 id="排列特性"><a href="#排列特性" class="headerlink" title="排列特性"></a><strong>排列特性</strong></h3><ol><li>浮动元素脱离标准流；<br>脱离标准流的控制，移动到指定位置；<strong>浮动的盒子不在保留原先位置。</strong>影响后面的标准流。</li><li>浮动元素一行内显示，顶部对齐；<br>父级宽度不够时，另起一行显示。</li><li>浮动元素具有行内块元素特性。<br>行内元素/块级元素都可以。<br>如果块级盒子没有设置宽度，默认和父级一样宽。添加浮动后，大小根据内容定。</li></ol><h3 id="浮动元素和标准流父级搭配使用"><a href="#浮动元素和标准流父级搭配使用" class="headerlink" title="浮动元素和标准流父级搭配使用"></a><strong>浮动元素和标准流父级搭配使用</strong></h3><p>先用标准流父级上下排列，内部子元素浮动排列左右位置。</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>为什么需要清除浮动：父元素不一定有高度，盒子浮动不占有位置。<br>本质：清除浮动的影响。<br>清除浮动的方法： <code>clear: left/right/both</code>闭合浮动</p><ol><li>额外标签法：最后一个元素末尾添加空标签（必须是块级元素），结构性较差；</li><li>父级添加<code>overflow:hidden, auto, scroll</code>，无法显示溢出；</li><li>after伪元素；</li><li>双伪元素。</li></ol><h2 id="emmet语法"><a href="#emmet语法" class="headerlink" title="emmet语法"></a>emmet语法</h2><p>基本采取简写形式即可。<br>如：width：100px；（w100px）</p><hr><h1 id="查阅文档"><a href="#查阅文档" class="headerlink" title="查阅文档"></a>查阅文档</h1><p>查阅文档是一个好习惯。w3c，mozilla都是可用的资源。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> CN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
